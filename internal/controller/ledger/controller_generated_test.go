// Code generated by MockGen. DO NOT EDIT.
//
// Generated by this command:
//
//	mockgen -write_source_comment=false -typed -write_package_comment=false -source controller.go -destination controller_generated_test.go -package ledger . Controller
//

package ledger

import (
	context "context"
	sql "database/sql"
	reflect "reflect"

	bunpaginate "github.com/formancehq/go-libs/v3/bun/bunpaginate"
	migrations "github.com/formancehq/go-libs/v3/migrations"
	ledger "github.com/formancehq/ledger/internal"
	common "github.com/formancehq/ledger/internal/storage/common"
	ledger0 "github.com/formancehq/ledger/internal/storage/ledger"
	bun "github.com/uptrace/bun"
	gomock "go.uber.org/mock/gomock"
)

// MockController is a mock of Controller interface.
type MockController struct {
	ctrl     *gomock.Controller
	recorder *MockControllerMockRecorder
	isgomock struct{}
}

// MockControllerMockRecorder is the mock recorder for MockController.
type MockControllerMockRecorder struct {
	mock *MockController
}

// NewMockController creates a new mock instance.
func NewMockController(ctrl *gomock.Controller) *MockController {
	mock := &MockController{ctrl: ctrl}
	mock.recorder = &MockControllerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockController) EXPECT() *MockControllerMockRecorder {
	return m.recorder
}

// BeginTX mocks base method.
func (m *MockController) BeginTX(ctx context.Context, options *sql.TxOptions) (Controller, *bun.Tx, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "BeginTX", ctx, options)
	ret0, _ := ret[0].(Controller)
	ret1, _ := ret[1].(*bun.Tx)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// BeginTX indicates an expected call of BeginTX.
func (mr *MockControllerMockRecorder) BeginTX(ctx, options any) *MockControllerBeginTXCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BeginTX", reflect.TypeOf((*MockController)(nil).BeginTX), ctx, options)
	return &MockControllerBeginTXCall{Call: call}
}

// MockControllerBeginTXCall wrap *gomock.Call
type MockControllerBeginTXCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockControllerBeginTXCall) Return(arg0 Controller, arg1 *bun.Tx, arg2 error) *MockControllerBeginTXCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockControllerBeginTXCall) Do(f func(context.Context, *sql.TxOptions) (Controller, *bun.Tx, error)) *MockControllerBeginTXCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockControllerBeginTXCall) DoAndReturn(f func(context.Context, *sql.TxOptions) (Controller, *bun.Tx, error)) *MockControllerBeginTXCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Commit mocks base method.
func (m *MockController) Commit(ctx context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Commit", ctx)
	ret0, _ := ret[0].(error)
	return ret0
}

// Commit indicates an expected call of Commit.
func (mr *MockControllerMockRecorder) Commit(ctx any) *MockControllerCommitCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Commit", reflect.TypeOf((*MockController)(nil).Commit), ctx)
	return &MockControllerCommitCall{Call: call}
}

// MockControllerCommitCall wrap *gomock.Call
type MockControllerCommitCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockControllerCommitCall) Return(arg0 error) *MockControllerCommitCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockControllerCommitCall) Do(f func(context.Context) error) *MockControllerCommitCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockControllerCommitCall) DoAndReturn(f func(context.Context) error) *MockControllerCommitCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// CountAccounts mocks base method.
func (m *MockController) CountAccounts(ctx context.Context, query common.ResourceQuery[any]) (int, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CountAccounts", ctx, query)
	ret0, _ := ret[0].(int)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CountAccounts indicates an expected call of CountAccounts.
func (mr *MockControllerMockRecorder) CountAccounts(ctx, query any) *MockControllerCountAccountsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CountAccounts", reflect.TypeOf((*MockController)(nil).CountAccounts), ctx, query)
	return &MockControllerCountAccountsCall{Call: call}
}

// MockControllerCountAccountsCall wrap *gomock.Call
type MockControllerCountAccountsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockControllerCountAccountsCall) Return(arg0 int, arg1 error) *MockControllerCountAccountsCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockControllerCountAccountsCall) Do(f func(context.Context, common.ResourceQuery[any]) (int, error)) *MockControllerCountAccountsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockControllerCountAccountsCall) DoAndReturn(f func(context.Context, common.ResourceQuery[any]) (int, error)) *MockControllerCountAccountsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// CountTransactions mocks base method.
func (m *MockController) CountTransactions(ctx context.Context, query common.ResourceQuery[any]) (int, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CountTransactions", ctx, query)
	ret0, _ := ret[0].(int)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CountTransactions indicates an expected call of CountTransactions.
func (mr *MockControllerMockRecorder) CountTransactions(ctx, query any) *MockControllerCountTransactionsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CountTransactions", reflect.TypeOf((*MockController)(nil).CountTransactions), ctx, query)
	return &MockControllerCountTransactionsCall{Call: call}
}

// MockControllerCountTransactionsCall wrap *gomock.Call
type MockControllerCountTransactionsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockControllerCountTransactionsCall) Return(arg0 int, arg1 error) *MockControllerCountTransactionsCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockControllerCountTransactionsCall) Do(f func(context.Context, common.ResourceQuery[any]) (int, error)) *MockControllerCountTransactionsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockControllerCountTransactionsCall) DoAndReturn(f func(context.Context, common.ResourceQuery[any]) (int, error)) *MockControllerCountTransactionsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// CreateTransaction mocks base method.
func (m *MockController) CreateTransaction(ctx context.Context, parameters Parameters[CreateTransaction]) (*ledger.Log, *ledger.CreatedTransaction, bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateTransaction", ctx, parameters)
	ret0, _ := ret[0].(*ledger.Log)
	ret1, _ := ret[1].(*ledger.CreatedTransaction)
	ret2, _ := ret[2].(bool)
	ret3, _ := ret[3].(error)
	return ret0, ret1, ret2, ret3
}

// CreateTransaction indicates an expected call of CreateTransaction.
func (mr *MockControllerMockRecorder) CreateTransaction(ctx, parameters any) *MockControllerCreateTransactionCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateTransaction", reflect.TypeOf((*MockController)(nil).CreateTransaction), ctx, parameters)
	return &MockControllerCreateTransactionCall{Call: call}
}

// MockControllerCreateTransactionCall wrap *gomock.Call
type MockControllerCreateTransactionCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockControllerCreateTransactionCall) Return(arg0 *ledger.Log, arg1 *ledger.CreatedTransaction, arg2 bool, arg3 error) *MockControllerCreateTransactionCall {
	c.Call = c.Call.Return(arg0, arg1, arg2, arg3)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockControllerCreateTransactionCall) Do(f func(context.Context, Parameters[CreateTransaction]) (*ledger.Log, *ledger.CreatedTransaction, bool, error)) *MockControllerCreateTransactionCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockControllerCreateTransactionCall) DoAndReturn(f func(context.Context, Parameters[CreateTransaction]) (*ledger.Log, *ledger.CreatedTransaction, bool, error)) *MockControllerCreateTransactionCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// DeleteAccountMetadata mocks base method.
func (m *MockController) DeleteAccountMetadata(ctx context.Context, parameters Parameters[DeleteAccountMetadata]) (*ledger.Log, bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DeleteAccountMetadata", ctx, parameters)
	ret0, _ := ret[0].(*ledger.Log)
	ret1, _ := ret[1].(bool)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// DeleteAccountMetadata indicates an expected call of DeleteAccountMetadata.
func (mr *MockControllerMockRecorder) DeleteAccountMetadata(ctx, parameters any) *MockControllerDeleteAccountMetadataCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteAccountMetadata", reflect.TypeOf((*MockController)(nil).DeleteAccountMetadata), ctx, parameters)
	return &MockControllerDeleteAccountMetadataCall{Call: call}
}

// MockControllerDeleteAccountMetadataCall wrap *gomock.Call
type MockControllerDeleteAccountMetadataCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockControllerDeleteAccountMetadataCall) Return(arg0 *ledger.Log, arg1 bool, arg2 error) *MockControllerDeleteAccountMetadataCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockControllerDeleteAccountMetadataCall) Do(f func(context.Context, Parameters[DeleteAccountMetadata]) (*ledger.Log, bool, error)) *MockControllerDeleteAccountMetadataCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockControllerDeleteAccountMetadataCall) DoAndReturn(f func(context.Context, Parameters[DeleteAccountMetadata]) (*ledger.Log, bool, error)) *MockControllerDeleteAccountMetadataCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// DeleteTransactionMetadata mocks base method.
func (m *MockController) DeleteTransactionMetadata(ctx context.Context, parameters Parameters[DeleteTransactionMetadata]) (*ledger.Log, bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DeleteTransactionMetadata", ctx, parameters)
	ret0, _ := ret[0].(*ledger.Log)
	ret1, _ := ret[1].(bool)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// DeleteTransactionMetadata indicates an expected call of DeleteTransactionMetadata.
func (mr *MockControllerMockRecorder) DeleteTransactionMetadata(ctx, parameters any) *MockControllerDeleteTransactionMetadataCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteTransactionMetadata", reflect.TypeOf((*MockController)(nil).DeleteTransactionMetadata), ctx, parameters)
	return &MockControllerDeleteTransactionMetadataCall{Call: call}
}

// MockControllerDeleteTransactionMetadataCall wrap *gomock.Call
type MockControllerDeleteTransactionMetadataCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockControllerDeleteTransactionMetadataCall) Return(arg0 *ledger.Log, arg1 bool, arg2 error) *MockControllerDeleteTransactionMetadataCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockControllerDeleteTransactionMetadataCall) Do(f func(context.Context, Parameters[DeleteTransactionMetadata]) (*ledger.Log, bool, error)) *MockControllerDeleteTransactionMetadataCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockControllerDeleteTransactionMetadataCall) DoAndReturn(f func(context.Context, Parameters[DeleteTransactionMetadata]) (*ledger.Log, bool, error)) *MockControllerDeleteTransactionMetadataCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Export mocks base method.
func (m *MockController) Export(ctx context.Context, w ExportWriter) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Export", ctx, w)
	ret0, _ := ret[0].(error)
	return ret0
}

// Export indicates an expected call of Export.
func (mr *MockControllerMockRecorder) Export(ctx, w any) *MockControllerExportCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Export", reflect.TypeOf((*MockController)(nil).Export), ctx, w)
	return &MockControllerExportCall{Call: call}
}

// MockControllerExportCall wrap *gomock.Call
type MockControllerExportCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockControllerExportCall) Return(arg0 error) *MockControllerExportCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockControllerExportCall) Do(f func(context.Context, ExportWriter) error) *MockControllerExportCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockControllerExportCall) DoAndReturn(f func(context.Context, ExportWriter) error) *MockControllerExportCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetAccount mocks base method.
func (m *MockController) GetAccount(ctx context.Context, query common.ResourceQuery[any]) (*ledger.Account, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetAccount", ctx, query)
	ret0, _ := ret[0].(*ledger.Account)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetAccount indicates an expected call of GetAccount.
func (mr *MockControllerMockRecorder) GetAccount(ctx, query any) *MockControllerGetAccountCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAccount", reflect.TypeOf((*MockController)(nil).GetAccount), ctx, query)
	return &MockControllerGetAccountCall{Call: call}
}

// MockControllerGetAccountCall wrap *gomock.Call
type MockControllerGetAccountCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockControllerGetAccountCall) Return(arg0 *ledger.Account, arg1 error) *MockControllerGetAccountCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockControllerGetAccountCall) Do(f func(context.Context, common.ResourceQuery[any]) (*ledger.Account, error)) *MockControllerGetAccountCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockControllerGetAccountCall) DoAndReturn(f func(context.Context, common.ResourceQuery[any]) (*ledger.Account, error)) *MockControllerGetAccountCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetAggregatedBalances mocks base method.
func (m *MockController) GetAggregatedBalances(ctx context.Context, q common.ResourceQuery[ledger0.GetAggregatedVolumesOptions]) (ledger.BalancesByAssets, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetAggregatedBalances", ctx, q)
	ret0, _ := ret[0].(ledger.BalancesByAssets)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetAggregatedBalances indicates an expected call of GetAggregatedBalances.
func (mr *MockControllerMockRecorder) GetAggregatedBalances(ctx, q any) *MockControllerGetAggregatedBalancesCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAggregatedBalances", reflect.TypeOf((*MockController)(nil).GetAggregatedBalances), ctx, q)
	return &MockControllerGetAggregatedBalancesCall{Call: call}
}

// MockControllerGetAggregatedBalancesCall wrap *gomock.Call
type MockControllerGetAggregatedBalancesCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockControllerGetAggregatedBalancesCall) Return(arg0 ledger.BalancesByAssets, arg1 error) *MockControllerGetAggregatedBalancesCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockControllerGetAggregatedBalancesCall) Do(f func(context.Context, common.ResourceQuery[ledger0.GetAggregatedVolumesOptions]) (ledger.BalancesByAssets, error)) *MockControllerGetAggregatedBalancesCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockControllerGetAggregatedBalancesCall) DoAndReturn(f func(context.Context, common.ResourceQuery[ledger0.GetAggregatedVolumesOptions]) (ledger.BalancesByAssets, error)) *MockControllerGetAggregatedBalancesCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetMigrationsInfo mocks base method.
func (m *MockController) GetMigrationsInfo(ctx context.Context) ([]migrations.Info, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetMigrationsInfo", ctx)
	ret0, _ := ret[0].([]migrations.Info)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetMigrationsInfo indicates an expected call of GetMigrationsInfo.
func (mr *MockControllerMockRecorder) GetMigrationsInfo(ctx any) *MockControllerGetMigrationsInfoCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetMigrationsInfo", reflect.TypeOf((*MockController)(nil).GetMigrationsInfo), ctx)
	return &MockControllerGetMigrationsInfoCall{Call: call}
}

// MockControllerGetMigrationsInfoCall wrap *gomock.Call
type MockControllerGetMigrationsInfoCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockControllerGetMigrationsInfoCall) Return(arg0 []migrations.Info, arg1 error) *MockControllerGetMigrationsInfoCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockControllerGetMigrationsInfoCall) Do(f func(context.Context) ([]migrations.Info, error)) *MockControllerGetMigrationsInfoCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockControllerGetMigrationsInfoCall) DoAndReturn(f func(context.Context) ([]migrations.Info, error)) *MockControllerGetMigrationsInfoCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetSchema mocks base method.
func (m *MockController) GetSchema(ctx context.Context, version string) (*ledger.Schema, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetSchema", ctx, version)
	ret0, _ := ret[0].(*ledger.Schema)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetSchema indicates an expected call of GetSchema.
func (mr *MockControllerMockRecorder) GetSchema(ctx, version any) *MockControllerGetSchemaCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetSchema", reflect.TypeOf((*MockController)(nil).GetSchema), ctx, version)
	return &MockControllerGetSchemaCall{Call: call}
}

// MockControllerGetSchemaCall wrap *gomock.Call
type MockControllerGetSchemaCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockControllerGetSchemaCall) Return(arg0 *ledger.Schema, arg1 error) *MockControllerGetSchemaCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockControllerGetSchemaCall) Do(f func(context.Context, string) (*ledger.Schema, error)) *MockControllerGetSchemaCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockControllerGetSchemaCall) DoAndReturn(f func(context.Context, string) (*ledger.Schema, error)) *MockControllerGetSchemaCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetStats mocks base method.
func (m *MockController) GetStats(ctx context.Context) (Stats, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetStats", ctx)
	ret0, _ := ret[0].(Stats)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetStats indicates an expected call of GetStats.
func (mr *MockControllerMockRecorder) GetStats(ctx any) *MockControllerGetStatsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetStats", reflect.TypeOf((*MockController)(nil).GetStats), ctx)
	return &MockControllerGetStatsCall{Call: call}
}

// MockControllerGetStatsCall wrap *gomock.Call
type MockControllerGetStatsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockControllerGetStatsCall) Return(arg0 Stats, arg1 error) *MockControllerGetStatsCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockControllerGetStatsCall) Do(f func(context.Context) (Stats, error)) *MockControllerGetStatsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockControllerGetStatsCall) DoAndReturn(f func(context.Context) (Stats, error)) *MockControllerGetStatsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetTransaction mocks base method.
func (m *MockController) GetTransaction(ctx context.Context, query common.ResourceQuery[any]) (*ledger.Transaction, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetTransaction", ctx, query)
	ret0, _ := ret[0].(*ledger.Transaction)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetTransaction indicates an expected call of GetTransaction.
func (mr *MockControllerMockRecorder) GetTransaction(ctx, query any) *MockControllerGetTransactionCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetTransaction", reflect.TypeOf((*MockController)(nil).GetTransaction), ctx, query)
	return &MockControllerGetTransactionCall{Call: call}
}

// MockControllerGetTransactionCall wrap *gomock.Call
type MockControllerGetTransactionCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockControllerGetTransactionCall) Return(arg0 *ledger.Transaction, arg1 error) *MockControllerGetTransactionCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockControllerGetTransactionCall) Do(f func(context.Context, common.ResourceQuery[any]) (*ledger.Transaction, error)) *MockControllerGetTransactionCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockControllerGetTransactionCall) DoAndReturn(f func(context.Context, common.ResourceQuery[any]) (*ledger.Transaction, error)) *MockControllerGetTransactionCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetVolumesWithBalances mocks base method.
func (m *MockController) GetVolumesWithBalances(ctx context.Context, q common.PaginatedQuery[ledger0.GetVolumesOptions]) (*bunpaginate.Cursor[ledger.VolumesWithBalanceByAssetByAccount], error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetVolumesWithBalances", ctx, q)
	ret0, _ := ret[0].(*bunpaginate.Cursor[ledger.VolumesWithBalanceByAssetByAccount])
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetVolumesWithBalances indicates an expected call of GetVolumesWithBalances.
func (mr *MockControllerMockRecorder) GetVolumesWithBalances(ctx, q any) *MockControllerGetVolumesWithBalancesCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetVolumesWithBalances", reflect.TypeOf((*MockController)(nil).GetVolumesWithBalances), ctx, q)
	return &MockControllerGetVolumesWithBalancesCall{Call: call}
}

// MockControllerGetVolumesWithBalancesCall wrap *gomock.Call
type MockControllerGetVolumesWithBalancesCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockControllerGetVolumesWithBalancesCall) Return(arg0 *bunpaginate.Cursor[ledger.VolumesWithBalanceByAssetByAccount], arg1 error) *MockControllerGetVolumesWithBalancesCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockControllerGetVolumesWithBalancesCall) Do(f func(context.Context, common.PaginatedQuery[ledger0.GetVolumesOptions]) (*bunpaginate.Cursor[ledger.VolumesWithBalanceByAssetByAccount], error)) *MockControllerGetVolumesWithBalancesCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockControllerGetVolumesWithBalancesCall) DoAndReturn(f func(context.Context, common.PaginatedQuery[ledger0.GetVolumesOptions]) (*bunpaginate.Cursor[ledger.VolumesWithBalanceByAssetByAccount], error)) *MockControllerGetVolumesWithBalancesCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Import mocks base method.
func (m *MockController) Import(ctx context.Context, stream chan ledger.Log) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Import", ctx, stream)
	ret0, _ := ret[0].(error)
	return ret0
}

// Import indicates an expected call of Import.
func (mr *MockControllerMockRecorder) Import(ctx, stream any) *MockControllerImportCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Import", reflect.TypeOf((*MockController)(nil).Import), ctx, stream)
	return &MockControllerImportCall{Call: call}
}

// MockControllerImportCall wrap *gomock.Call
type MockControllerImportCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockControllerImportCall) Return(arg0 error) *MockControllerImportCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockControllerImportCall) Do(f func(context.Context, chan ledger.Log) error) *MockControllerImportCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockControllerImportCall) DoAndReturn(f func(context.Context, chan ledger.Log) error) *MockControllerImportCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Info mocks base method.
func (m *MockController) Info() ledger.Ledger {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Info")
	ret0, _ := ret[0].(ledger.Ledger)
	return ret0
}

// Info indicates an expected call of Info.
func (mr *MockControllerMockRecorder) Info() *MockControllerInfoCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Info", reflect.TypeOf((*MockController)(nil).Info))
	return &MockControllerInfoCall{Call: call}
}

// MockControllerInfoCall wrap *gomock.Call
type MockControllerInfoCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockControllerInfoCall) Return(arg0 ledger.Ledger) *MockControllerInfoCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockControllerInfoCall) Do(f func() ledger.Ledger) *MockControllerInfoCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockControllerInfoCall) DoAndReturn(f func() ledger.Ledger) *MockControllerInfoCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// InsertSchema mocks base method.
func (m *MockController) InsertSchema(ctx context.Context, parameters Parameters[InsertSchema]) (*ledger.Log, *ledger.InsertedSchema, bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "InsertSchema", ctx, parameters)
	ret0, _ := ret[0].(*ledger.Log)
	ret1, _ := ret[1].(*ledger.InsertedSchema)
	ret2, _ := ret[2].(bool)
	ret3, _ := ret[3].(error)
	return ret0, ret1, ret2, ret3
}

// InsertSchema indicates an expected call of InsertSchema.
func (mr *MockControllerMockRecorder) InsertSchema(ctx, parameters any) *MockControllerInsertSchemaCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InsertSchema", reflect.TypeOf((*MockController)(nil).InsertSchema), ctx, parameters)
	return &MockControllerInsertSchemaCall{Call: call}
}

// MockControllerInsertSchemaCall wrap *gomock.Call
type MockControllerInsertSchemaCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockControllerInsertSchemaCall) Return(arg0 *ledger.Log, arg1 *ledger.InsertedSchema, arg2 bool, arg3 error) *MockControllerInsertSchemaCall {
	c.Call = c.Call.Return(arg0, arg1, arg2, arg3)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockControllerInsertSchemaCall) Do(f func(context.Context, Parameters[InsertSchema]) (*ledger.Log, *ledger.InsertedSchema, bool, error)) *MockControllerInsertSchemaCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockControllerInsertSchemaCall) DoAndReturn(f func(context.Context, Parameters[InsertSchema]) (*ledger.Log, *ledger.InsertedSchema, bool, error)) *MockControllerInsertSchemaCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// IsDatabaseUpToDate mocks base method.
func (m *MockController) IsDatabaseUpToDate(ctx context.Context) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsDatabaseUpToDate", ctx)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IsDatabaseUpToDate indicates an expected call of IsDatabaseUpToDate.
func (mr *MockControllerMockRecorder) IsDatabaseUpToDate(ctx any) *MockControllerIsDatabaseUpToDateCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsDatabaseUpToDate", reflect.TypeOf((*MockController)(nil).IsDatabaseUpToDate), ctx)
	return &MockControllerIsDatabaseUpToDateCall{Call: call}
}

// MockControllerIsDatabaseUpToDateCall wrap *gomock.Call
type MockControllerIsDatabaseUpToDateCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockControllerIsDatabaseUpToDateCall) Return(arg0 bool, arg1 error) *MockControllerIsDatabaseUpToDateCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockControllerIsDatabaseUpToDateCall) Do(f func(context.Context) (bool, error)) *MockControllerIsDatabaseUpToDateCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockControllerIsDatabaseUpToDateCall) DoAndReturn(f func(context.Context) (bool, error)) *MockControllerIsDatabaseUpToDateCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ListAccounts mocks base method.
func (m *MockController) ListAccounts(ctx context.Context, query common.PaginatedQuery[any]) (*bunpaginate.Cursor[ledger.Account], error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ListAccounts", ctx, query)
	ret0, _ := ret[0].(*bunpaginate.Cursor[ledger.Account])
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListAccounts indicates an expected call of ListAccounts.
func (mr *MockControllerMockRecorder) ListAccounts(ctx, query any) *MockControllerListAccountsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListAccounts", reflect.TypeOf((*MockController)(nil).ListAccounts), ctx, query)
	return &MockControllerListAccountsCall{Call: call}
}

// MockControllerListAccountsCall wrap *gomock.Call
type MockControllerListAccountsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockControllerListAccountsCall) Return(arg0 *bunpaginate.Cursor[ledger.Account], arg1 error) *MockControllerListAccountsCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockControllerListAccountsCall) Do(f func(context.Context, common.PaginatedQuery[any]) (*bunpaginate.Cursor[ledger.Account], error)) *MockControllerListAccountsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockControllerListAccountsCall) DoAndReturn(f func(context.Context, common.PaginatedQuery[any]) (*bunpaginate.Cursor[ledger.Account], error)) *MockControllerListAccountsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ListLogs mocks base method.
func (m *MockController) ListLogs(ctx context.Context, query common.PaginatedQuery[any]) (*bunpaginate.Cursor[ledger.Log], error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ListLogs", ctx, query)
	ret0, _ := ret[0].(*bunpaginate.Cursor[ledger.Log])
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListLogs indicates an expected call of ListLogs.
func (mr *MockControllerMockRecorder) ListLogs(ctx, query any) *MockControllerListLogsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListLogs", reflect.TypeOf((*MockController)(nil).ListLogs), ctx, query)
	return &MockControllerListLogsCall{Call: call}
}

// MockControllerListLogsCall wrap *gomock.Call
type MockControllerListLogsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockControllerListLogsCall) Return(arg0 *bunpaginate.Cursor[ledger.Log], arg1 error) *MockControllerListLogsCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockControllerListLogsCall) Do(f func(context.Context, common.PaginatedQuery[any]) (*bunpaginate.Cursor[ledger.Log], error)) *MockControllerListLogsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockControllerListLogsCall) DoAndReturn(f func(context.Context, common.PaginatedQuery[any]) (*bunpaginate.Cursor[ledger.Log], error)) *MockControllerListLogsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ListSchemas mocks base method.
func (m *MockController) ListSchemas(ctx context.Context, query common.PaginatedQuery[any]) (*bunpaginate.Cursor[ledger.Schema], error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ListSchemas", ctx, query)
	ret0, _ := ret[0].(*bunpaginate.Cursor[ledger.Schema])
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListSchemas indicates an expected call of ListSchemas.
func (mr *MockControllerMockRecorder) ListSchemas(ctx, query any) *MockControllerListSchemasCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListSchemas", reflect.TypeOf((*MockController)(nil).ListSchemas), ctx, query)
	return &MockControllerListSchemasCall{Call: call}
}

// MockControllerListSchemasCall wrap *gomock.Call
type MockControllerListSchemasCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockControllerListSchemasCall) Return(arg0 *bunpaginate.Cursor[ledger.Schema], arg1 error) *MockControllerListSchemasCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockControllerListSchemasCall) Do(f func(context.Context, common.PaginatedQuery[any]) (*bunpaginate.Cursor[ledger.Schema], error)) *MockControllerListSchemasCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockControllerListSchemasCall) DoAndReturn(f func(context.Context, common.PaginatedQuery[any]) (*bunpaginate.Cursor[ledger.Schema], error)) *MockControllerListSchemasCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ListTransactions mocks base method.
func (m *MockController) ListTransactions(ctx context.Context, query common.PaginatedQuery[any]) (*bunpaginate.Cursor[ledger.Transaction], error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ListTransactions", ctx, query)
	ret0, _ := ret[0].(*bunpaginate.Cursor[ledger.Transaction])
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListTransactions indicates an expected call of ListTransactions.
func (mr *MockControllerMockRecorder) ListTransactions(ctx, query any) *MockControllerListTransactionsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListTransactions", reflect.TypeOf((*MockController)(nil).ListTransactions), ctx, query)
	return &MockControllerListTransactionsCall{Call: call}
}

// MockControllerListTransactionsCall wrap *gomock.Call
type MockControllerListTransactionsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockControllerListTransactionsCall) Return(arg0 *bunpaginate.Cursor[ledger.Transaction], arg1 error) *MockControllerListTransactionsCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockControllerListTransactionsCall) Do(f func(context.Context, common.PaginatedQuery[any]) (*bunpaginate.Cursor[ledger.Transaction], error)) *MockControllerListTransactionsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockControllerListTransactionsCall) DoAndReturn(f func(context.Context, common.PaginatedQuery[any]) (*bunpaginate.Cursor[ledger.Transaction], error)) *MockControllerListTransactionsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// LockLedger mocks base method.
func (m *MockController) LockLedger(ctx context.Context) (Controller, bun.IDB, func() error, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "LockLedger", ctx)
	ret0, _ := ret[0].(Controller)
	ret1, _ := ret[1].(bun.IDB)
	ret2, _ := ret[2].(func() error)
	ret3, _ := ret[3].(error)
	return ret0, ret1, ret2, ret3
}

// LockLedger indicates an expected call of LockLedger.
func (mr *MockControllerMockRecorder) LockLedger(ctx any) *MockControllerLockLedgerCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LockLedger", reflect.TypeOf((*MockController)(nil).LockLedger), ctx)
	return &MockControllerLockLedgerCall{Call: call}
}

// MockControllerLockLedgerCall wrap *gomock.Call
type MockControllerLockLedgerCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockControllerLockLedgerCall) Return(arg0 Controller, arg1 bun.IDB, arg2 func() error, arg3 error) *MockControllerLockLedgerCall {
	c.Call = c.Call.Return(arg0, arg1, arg2, arg3)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockControllerLockLedgerCall) Do(f func(context.Context) (Controller, bun.IDB, func() error, error)) *MockControllerLockLedgerCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockControllerLockLedgerCall) DoAndReturn(f func(context.Context) (Controller, bun.IDB, func() error, error)) *MockControllerLockLedgerCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// RevertTransaction mocks base method.
func (m *MockController) RevertTransaction(ctx context.Context, parameters Parameters[RevertTransaction]) (*ledger.Log, *ledger.RevertedTransaction, bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RevertTransaction", ctx, parameters)
	ret0, _ := ret[0].(*ledger.Log)
	ret1, _ := ret[1].(*ledger.RevertedTransaction)
	ret2, _ := ret[2].(bool)
	ret3, _ := ret[3].(error)
	return ret0, ret1, ret2, ret3
}

// RevertTransaction indicates an expected call of RevertTransaction.
func (mr *MockControllerMockRecorder) RevertTransaction(ctx, parameters any) *MockControllerRevertTransactionCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RevertTransaction", reflect.TypeOf((*MockController)(nil).RevertTransaction), ctx, parameters)
	return &MockControllerRevertTransactionCall{Call: call}
}

// MockControllerRevertTransactionCall wrap *gomock.Call
type MockControllerRevertTransactionCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockControllerRevertTransactionCall) Return(arg0 *ledger.Log, arg1 *ledger.RevertedTransaction, arg2 bool, arg3 error) *MockControllerRevertTransactionCall {
	c.Call = c.Call.Return(arg0, arg1, arg2, arg3)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockControllerRevertTransactionCall) Do(f func(context.Context, Parameters[RevertTransaction]) (*ledger.Log, *ledger.RevertedTransaction, bool, error)) *MockControllerRevertTransactionCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockControllerRevertTransactionCall) DoAndReturn(f func(context.Context, Parameters[RevertTransaction]) (*ledger.Log, *ledger.RevertedTransaction, bool, error)) *MockControllerRevertTransactionCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Rollback mocks base method.
func (m *MockController) Rollback(ctx context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Rollback", ctx)
	ret0, _ := ret[0].(error)
	return ret0
}

// Rollback indicates an expected call of Rollback.
func (mr *MockControllerMockRecorder) Rollback(ctx any) *MockControllerRollbackCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Rollback", reflect.TypeOf((*MockController)(nil).Rollback), ctx)
	return &MockControllerRollbackCall{Call: call}
}

// MockControllerRollbackCall wrap *gomock.Call
type MockControllerRollbackCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockControllerRollbackCall) Return(arg0 error) *MockControllerRollbackCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockControllerRollbackCall) Do(f func(context.Context) error) *MockControllerRollbackCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockControllerRollbackCall) DoAndReturn(f func(context.Context) error) *MockControllerRollbackCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// RunQuery mocks base method.
func (m *MockController) RunQuery(ctx context.Context, schemaVersion, queryId string, runQuery common.RunQuery, defaultPageSize uint64) (*bunpaginate.Cursor[any], error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RunQuery", ctx, schemaVersion, queryId, runQuery, defaultPageSize)
	ret0, _ := ret[0].(*bunpaginate.Cursor[any])
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// RunQuery indicates an expected call of RunQuery.
func (mr *MockControllerMockRecorder) RunQuery(ctx, schemaVersion, queryId, runQuery, defaultPageSize any) *MockControllerRunQueryCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RunQuery", reflect.TypeOf((*MockController)(nil).RunQuery), ctx, schemaVersion, queryId, runQuery, defaultPageSize)
	return &MockControllerRunQueryCall{Call: call}
}

// MockControllerRunQueryCall wrap *gomock.Call
type MockControllerRunQueryCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockControllerRunQueryCall) Return(arg0 *bunpaginate.Cursor[any], arg1 error) *MockControllerRunQueryCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockControllerRunQueryCall) Do(f func(context.Context, string, string, common.RunQuery, uint64) (*bunpaginate.Cursor[any], error)) *MockControllerRunQueryCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockControllerRunQueryCall) DoAndReturn(f func(context.Context, string, string, common.RunQuery, uint64) (*bunpaginate.Cursor[any], error)) *MockControllerRunQueryCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SaveAccountMetadata mocks base method.
func (m *MockController) SaveAccountMetadata(ctx context.Context, parameters Parameters[SaveAccountMetadata]) (*ledger.Log, bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SaveAccountMetadata", ctx, parameters)
	ret0, _ := ret[0].(*ledger.Log)
	ret1, _ := ret[1].(bool)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// SaveAccountMetadata indicates an expected call of SaveAccountMetadata.
func (mr *MockControllerMockRecorder) SaveAccountMetadata(ctx, parameters any) *MockControllerSaveAccountMetadataCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SaveAccountMetadata", reflect.TypeOf((*MockController)(nil).SaveAccountMetadata), ctx, parameters)
	return &MockControllerSaveAccountMetadataCall{Call: call}
}

// MockControllerSaveAccountMetadataCall wrap *gomock.Call
type MockControllerSaveAccountMetadataCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockControllerSaveAccountMetadataCall) Return(arg0 *ledger.Log, arg1 bool, arg2 error) *MockControllerSaveAccountMetadataCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockControllerSaveAccountMetadataCall) Do(f func(context.Context, Parameters[SaveAccountMetadata]) (*ledger.Log, bool, error)) *MockControllerSaveAccountMetadataCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockControllerSaveAccountMetadataCall) DoAndReturn(f func(context.Context, Parameters[SaveAccountMetadata]) (*ledger.Log, bool, error)) *MockControllerSaveAccountMetadataCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SaveTransactionMetadata mocks base method.
func (m *MockController) SaveTransactionMetadata(ctx context.Context, parameters Parameters[SaveTransactionMetadata]) (*ledger.Log, bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SaveTransactionMetadata", ctx, parameters)
	ret0, _ := ret[0].(*ledger.Log)
	ret1, _ := ret[1].(bool)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// SaveTransactionMetadata indicates an expected call of SaveTransactionMetadata.
func (mr *MockControllerMockRecorder) SaveTransactionMetadata(ctx, parameters any) *MockControllerSaveTransactionMetadataCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SaveTransactionMetadata", reflect.TypeOf((*MockController)(nil).SaveTransactionMetadata), ctx, parameters)
	return &MockControllerSaveTransactionMetadataCall{Call: call}
}

// MockControllerSaveTransactionMetadataCall wrap *gomock.Call
type MockControllerSaveTransactionMetadataCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockControllerSaveTransactionMetadataCall) Return(arg0 *ledger.Log, arg1 bool, arg2 error) *MockControllerSaveTransactionMetadataCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockControllerSaveTransactionMetadataCall) Do(f func(context.Context, Parameters[SaveTransactionMetadata]) (*ledger.Log, bool, error)) *MockControllerSaveTransactionMetadataCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockControllerSaveTransactionMetadataCall) DoAndReturn(f func(context.Context, Parameters[SaveTransactionMetadata]) (*ledger.Log, bool, error)) *MockControllerSaveTransactionMetadataCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}
