// Code generated by MockGen. DO NOT EDIT.
//
// Generated by this command:
//
//	mockgen -write_source_comment=false -write_package_comment=false -source store.go -destination store_generated_test.go -package ledger . Store
//

package ledger

import (
	context "context"
	sql "database/sql"
	reflect "reflect"

	bunpaginate "github.com/formancehq/go-libs/v3/bun/bunpaginate"
	metadata "github.com/formancehq/go-libs/v3/metadata"
	migrations "github.com/formancehq/go-libs/v3/migrations"
	time "github.com/formancehq/go-libs/v3/time"
	ledger "github.com/formancehq/ledger/internal"
	common "github.com/formancehq/ledger/internal/storage/common"
	ledger0 "github.com/formancehq/ledger/internal/storage/ledger"
	bun "github.com/uptrace/bun"
	gomock "go.uber.org/mock/gomock"
)

// MockStore is a mock of Store interface.
type MockStore struct {
	ctrl     *gomock.Controller
	recorder *MockStoreMockRecorder
	isgomock struct{}
}

// MockStoreMockRecorder is the mock recorder for MockStore.
type MockStoreMockRecorder struct {
	mock *MockStore
}

// NewMockStore creates a new mock instance.
func NewMockStore(ctrl *gomock.Controller) *MockStore {
	mock := &MockStore{ctrl: ctrl}
	mock.recorder = &MockStoreMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockStore) EXPECT() *MockStoreMockRecorder {
	return m.recorder
}

// Accounts mocks base method.
func (m *MockStore) Accounts() common.PaginatedResource[ledger.Account, any] {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Accounts")
	ret0, _ := ret[0].(common.PaginatedResource[ledger.Account, any])
	return ret0
}

// Accounts indicates an expected call of Accounts.
func (mr *MockStoreMockRecorder) Accounts() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Accounts", reflect.TypeOf((*MockStore)(nil).Accounts))
}

// AggregatedBalances mocks base method.
func (m *MockStore) AggregatedBalances() common.Resource[ledger.AggregatedVolumes, ledger0.GetAggregatedVolumesOptions] {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "AggregatedBalances")
	ret0, _ := ret[0].(common.Resource[ledger.AggregatedVolumes, ledger0.GetAggregatedVolumesOptions])
	return ret0
}

// AggregatedBalances indicates an expected call of AggregatedBalances.
func (mr *MockStoreMockRecorder) AggregatedBalances() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AggregatedBalances", reflect.TypeOf((*MockStore)(nil).AggregatedBalances))
}

// BeginTX mocks base method.
func (m *MockStore) BeginTX(ctx context.Context, options *sql.TxOptions) (Store, *bun.Tx, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "BeginTX", ctx, options)
	ret0, _ := ret[0].(Store)
	ret1, _ := ret[1].(*bun.Tx)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// BeginTX indicates an expected call of BeginTX.
func (mr *MockStoreMockRecorder) BeginTX(ctx, options any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BeginTX", reflect.TypeOf((*MockStore)(nil).BeginTX), ctx, options)
}

// Commit mocks base method.
func (m *MockStore) Commit(ctx context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Commit", ctx)
	ret0, _ := ret[0].(error)
	return ret0
}

// Commit indicates an expected call of Commit.
func (mr *MockStoreMockRecorder) Commit(ctx any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Commit", reflect.TypeOf((*MockStore)(nil).Commit), ctx)
}

// CommitTransaction mocks base method.
func (m *MockStore) CommitTransaction(ctx context.Context, transaction *ledger.Transaction, accountMetadata map[string]metadata.Metadata) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CommitTransaction", ctx, transaction, accountMetadata)
	ret0, _ := ret[0].(error)
	return ret0
}

// CommitTransaction indicates an expected call of CommitTransaction.
func (mr *MockStoreMockRecorder) CommitTransaction(ctx, transaction, accountMetadata any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CommitTransaction", reflect.TypeOf((*MockStore)(nil).CommitTransaction), ctx, transaction, accountMetadata)
}

// DeleteAccountMetadata mocks base method.
func (m *MockStore) DeleteAccountMetadata(ctx context.Context, address, key string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DeleteAccountMetadata", ctx, address, key)
	ret0, _ := ret[0].(error)
	return ret0
}

// DeleteAccountMetadata indicates an expected call of DeleteAccountMetadata.
func (mr *MockStoreMockRecorder) DeleteAccountMetadata(ctx, address, key any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteAccountMetadata", reflect.TypeOf((*MockStore)(nil).DeleteAccountMetadata), ctx, address, key)
}

// DeleteTransactionMetadata mocks base method.
func (m *MockStore) DeleteTransactionMetadata(ctx context.Context, transactionID uint64, key string, at time.Time) (*ledger.Transaction, bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DeleteTransactionMetadata", ctx, transactionID, key, at)
	ret0, _ := ret[0].(*ledger.Transaction)
	ret1, _ := ret[1].(bool)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// DeleteTransactionMetadata indicates an expected call of DeleteTransactionMetadata.
func (mr *MockStoreMockRecorder) DeleteTransactionMetadata(ctx, transactionID, key, at any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteTransactionMetadata", reflect.TypeOf((*MockStore)(nil).DeleteTransactionMetadata), ctx, transactionID, key, at)
}

// FindSchema mocks base method.
func (m *MockStore) FindSchema(ctx context.Context, version string) (*ledger.Schema, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FindSchema", ctx, version)
	ret0, _ := ret[0].(*ledger.Schema)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FindSchema indicates an expected call of FindSchema.
func (mr *MockStoreMockRecorder) FindSchema(ctx, version any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindSchema", reflect.TypeOf((*MockStore)(nil).FindSchema), ctx, version)
}

// FindSchemas mocks base method.
func (m *MockStore) FindSchemas(ctx context.Context, query common.PaginatedQuery[any]) (*bunpaginate.Cursor[ledger.Schema], error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FindSchemas", ctx, query)
	ret0, _ := ret[0].(*bunpaginate.Cursor[ledger.Schema])
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FindSchemas indicates an expected call of FindSchemas.
func (mr *MockStoreMockRecorder) FindSchemas(ctx, query any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindSchemas", reflect.TypeOf((*MockStore)(nil).FindSchemas), ctx, query)
}

// GetBalances mocks base method.
func (m *MockStore) GetBalances(ctx context.Context, query ledger0.BalanceQuery) (ledger.Balances, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetBalances", ctx, query)
	ret0, _ := ret[0].(ledger.Balances)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetBalances indicates an expected call of GetBalances.
func (mr *MockStoreMockRecorder) GetBalances(ctx, query any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetBalances", reflect.TypeOf((*MockStore)(nil).GetBalances), ctx, query)
}

// GetMigrationsInfo mocks base method.
func (m *MockStore) GetMigrationsInfo(ctx context.Context) ([]migrations.Info, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetMigrationsInfo", ctx)
	ret0, _ := ret[0].([]migrations.Info)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetMigrationsInfo indicates an expected call of GetMigrationsInfo.
func (mr *MockStoreMockRecorder) GetMigrationsInfo(ctx any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetMigrationsInfo", reflect.TypeOf((*MockStore)(nil).GetMigrationsInfo), ctx)
}

// InsertLog mocks base method.
func (m *MockStore) InsertLog(ctx context.Context, log *ledger.Log) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "InsertLog", ctx, log)
	ret0, _ := ret[0].(error)
	return ret0
}

// InsertLog indicates an expected call of InsertLog.
func (mr *MockStoreMockRecorder) InsertLog(ctx, log any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InsertLog", reflect.TypeOf((*MockStore)(nil).InsertLog), ctx, log)
}

// InsertSchema mocks base method.
func (m *MockStore) InsertSchema(ctx context.Context, data *ledger.Schema) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "InsertSchema", ctx, data)
	ret0, _ := ret[0].(error)
	return ret0
}

// InsertSchema indicates an expected call of InsertSchema.
func (mr *MockStoreMockRecorder) InsertSchema(ctx, data any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InsertSchema", reflect.TypeOf((*MockStore)(nil).InsertSchema), ctx, data)
}

// IsUpToDate mocks base method.
func (m *MockStore) IsUpToDate(ctx context.Context) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsUpToDate", ctx)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IsUpToDate indicates an expected call of IsUpToDate.
func (mr *MockStoreMockRecorder) IsUpToDate(ctx any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsUpToDate", reflect.TypeOf((*MockStore)(nil).IsUpToDate), ctx)
}

// LockLedger mocks base method.
func (m *MockStore) LockLedger(ctx context.Context) (Store, bun.IDB, func() error, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "LockLedger", ctx)
	ret0, _ := ret[0].(Store)
	ret1, _ := ret[1].(bun.IDB)
	ret2, _ := ret[2].(func() error)
	ret3, _ := ret[3].(error)
	return ret0, ret1, ret2, ret3
}

// LockLedger indicates an expected call of LockLedger.
func (mr *MockStoreMockRecorder) LockLedger(ctx any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LockLedger", reflect.TypeOf((*MockStore)(nil).LockLedger), ctx)
}

// Logs mocks base method.
func (m *MockStore) Logs() common.PaginatedResource[ledger.Log, any] {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Logs")
	ret0, _ := ret[0].(common.PaginatedResource[ledger.Log, any])
	return ret0
}

// Logs indicates an expected call of Logs.
func (mr *MockStoreMockRecorder) Logs() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Logs", reflect.TypeOf((*MockStore)(nil).Logs))
}

// ReadLogWithIdempotencyKey mocks base method.
func (m *MockStore) ReadLogWithIdempotencyKey(ctx context.Context, ik string) (*ledger.Log, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ReadLogWithIdempotencyKey", ctx, ik)
	ret0, _ := ret[0].(*ledger.Log)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ReadLogWithIdempotencyKey indicates an expected call of ReadLogWithIdempotencyKey.
func (mr *MockStoreMockRecorder) ReadLogWithIdempotencyKey(ctx, ik any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReadLogWithIdempotencyKey", reflect.TypeOf((*MockStore)(nil).ReadLogWithIdempotencyKey), ctx, ik)
}

// RevertTransaction mocks base method.
func (m *MockStore) RevertTransaction(ctx context.Context, id uint64, at time.Time) (*ledger.Transaction, bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RevertTransaction", ctx, id, at)
	ret0, _ := ret[0].(*ledger.Transaction)
	ret1, _ := ret[1].(bool)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// RevertTransaction indicates an expected call of RevertTransaction.
func (mr *MockStoreMockRecorder) RevertTransaction(ctx, id, at any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RevertTransaction", reflect.TypeOf((*MockStore)(nil).RevertTransaction), ctx, id, at)
}

// Rollback mocks base method.
func (m *MockStore) Rollback(ctx context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Rollback", ctx)
	ret0, _ := ret[0].(error)
	return ret0
}

// Rollback indicates an expected call of Rollback.
func (mr *MockStoreMockRecorder) Rollback(ctx any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Rollback", reflect.TypeOf((*MockStore)(nil).Rollback), ctx)
}

// Transactions mocks base method.
func (m *MockStore) Transactions() common.PaginatedResource[ledger.Transaction, any] {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Transactions")
	ret0, _ := ret[0].(common.PaginatedResource[ledger.Transaction, any])
	return ret0
}

// Transactions indicates an expected call of Transactions.
func (mr *MockStoreMockRecorder) Transactions() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Transactions", reflect.TypeOf((*MockStore)(nil).Transactions))
}

// UpdateAccountsMetadata mocks base method.
func (m_2 *MockStore) UpdateAccountsMetadata(ctx context.Context, m map[string]metadata.Metadata, at time.Time) error {
	m_2.ctrl.T.Helper()
	ret := m_2.ctrl.Call(m_2, "UpdateAccountsMetadata", ctx, m, at)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpdateAccountsMetadata indicates an expected call of UpdateAccountsMetadata.
func (mr *MockStoreMockRecorder) UpdateAccountsMetadata(ctx, m, at any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateAccountsMetadata", reflect.TypeOf((*MockStore)(nil).UpdateAccountsMetadata), ctx, m, at)
}

// UpdateTransactionMetadata mocks base method.
func (m_2 *MockStore) UpdateTransactionMetadata(ctx context.Context, transactionID uint64, m metadata.Metadata, at time.Time) (*ledger.Transaction, bool, error) {
	m_2.ctrl.T.Helper()
	ret := m_2.ctrl.Call(m_2, "UpdateTransactionMetadata", ctx, transactionID, m, at)
	ret0, _ := ret[0].(*ledger.Transaction)
	ret1, _ := ret[1].(bool)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// UpdateTransactionMetadata indicates an expected call of UpdateTransactionMetadata.
func (mr *MockStoreMockRecorder) UpdateTransactionMetadata(ctx, transactionID, m, at any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateTransactionMetadata", reflect.TypeOf((*MockStore)(nil).UpdateTransactionMetadata), ctx, transactionID, m, at)
}

// UpsertAccounts mocks base method.
func (m *MockStore) UpsertAccounts(ctx context.Context, accounts ...*ledger.Account) error {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range accounts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "UpsertAccounts", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpsertAccounts indicates an expected call of UpsertAccounts.
func (mr *MockStoreMockRecorder) UpsertAccounts(ctx any, accounts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, accounts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpsertAccounts", reflect.TypeOf((*MockStore)(nil).UpsertAccounts), varargs...)
}

// Volumes mocks base method.
func (m *MockStore) Volumes() common.PaginatedResource[ledger.VolumesWithBalanceByAssetByAccount, ledger0.GetVolumesOptions] {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Volumes")
	ret0, _ := ret[0].(common.PaginatedResource[ledger.VolumesWithBalanceByAssetByAccount, ledger0.GetVolumesOptions])
	return ret0
}

// Volumes indicates an expected call of Volumes.
func (mr *MockStoreMockRecorder) Volumes() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Volumes", reflect.TypeOf((*MockStore)(nil).Volumes))
}
