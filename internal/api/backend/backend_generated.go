// Code generated by MockGen. DO NOT EDIT.
// Source: backend.go
//
// Generated by this command:
//
//	mockgen -source backend.go -destination backend_generated.go -package backend . Ledger
//

// Package backend is a generated GoMock package.
package backend

import (
	context "context"
	big "math/big"
	reflect "reflect"

	ledger "github.com/formancehq/ledger/internal"
	engine "github.com/formancehq/ledger/internal/engine"
	command "github.com/formancehq/ledger/internal/engine/command"
	driver "github.com/formancehq/ledger/internal/storage/driver"
	ledgerstore "github.com/formancehq/ledger/internal/storage/ledgerstore"
	systemstore "github.com/formancehq/ledger/internal/storage/systemstore"
	bunpaginate "github.com/formancehq/stack/libs/go-libs/bun/bunpaginate"
	metadata "github.com/formancehq/stack/libs/go-libs/metadata"
	migrations "github.com/formancehq/stack/libs/go-libs/migrations"
	gomock "go.uber.org/mock/gomock"
)

// MockLedger is a mock of Ledger interface.
type MockLedger struct {
	ctrl     *gomock.Controller
	recorder *MockLedgerMockRecorder
}

// MockLedgerMockRecorder is the mock recorder for MockLedger.
type MockLedgerMockRecorder struct {
	mock *MockLedger
}

// NewMockLedger creates a new mock instance.
func NewMockLedger(ctrl *gomock.Controller) *MockLedger {
	mock := &MockLedger{ctrl: ctrl}
	mock.recorder = &MockLedgerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockLedger) EXPECT() *MockLedgerMockRecorder {
	return m.recorder
}

// CountAccounts mocks base method.
func (m *MockLedger) CountAccounts(ctx context.Context, query ledgerstore.GetAccountsQuery) (int, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CountAccounts", ctx, query)
	ret0, _ := ret[0].(int)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CountAccounts indicates an expected call of CountAccounts.
func (mr *MockLedgerMockRecorder) CountAccounts(ctx, query any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CountAccounts", reflect.TypeOf((*MockLedger)(nil).CountAccounts), ctx, query)
}

// CountTransactions mocks base method.
func (m *MockLedger) CountTransactions(ctx context.Context, query ledgerstore.GetTransactionsQuery) (int, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CountTransactions", ctx, query)
	ret0, _ := ret[0].(int)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CountTransactions indicates an expected call of CountTransactions.
func (mr *MockLedgerMockRecorder) CountTransactions(ctx, query any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CountTransactions", reflect.TypeOf((*MockLedger)(nil).CountTransactions), ctx, query)
}

// CreateTransaction mocks base method.
func (m *MockLedger) CreateTransaction(ctx context.Context, parameters command.Parameters, data ledger.RunScript) (*ledger.Transaction, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateTransaction", ctx, parameters, data)
	ret0, _ := ret[0].(*ledger.Transaction)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CreateTransaction indicates an expected call of CreateTransaction.
func (mr *MockLedgerMockRecorder) CreateTransaction(ctx, parameters, data any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateTransaction", reflect.TypeOf((*MockLedger)(nil).CreateTransaction), ctx, parameters, data)
}

// DeleteMetadata mocks base method.
func (m *MockLedger) DeleteMetadata(ctx context.Context, parameters command.Parameters, targetType string, targetID any, key string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DeleteMetadata", ctx, parameters, targetType, targetID, key)
	ret0, _ := ret[0].(error)
	return ret0
}

// DeleteMetadata indicates an expected call of DeleteMetadata.
func (mr *MockLedgerMockRecorder) DeleteMetadata(ctx, parameters, targetType, targetID, key any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteMetadata", reflect.TypeOf((*MockLedger)(nil).DeleteMetadata), ctx, parameters, targetType, targetID, key)
}

// GetAccountWithVolumes mocks base method.
func (m *MockLedger) GetAccountWithVolumes(ctx context.Context, query ledgerstore.GetAccountQuery) (*ledger.ExpandedAccount, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetAccountWithVolumes", ctx, query)
	ret0, _ := ret[0].(*ledger.ExpandedAccount)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetAccountWithVolumes indicates an expected call of GetAccountWithVolumes.
func (mr *MockLedgerMockRecorder) GetAccountWithVolumes(ctx, query any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAccountWithVolumes", reflect.TypeOf((*MockLedger)(nil).GetAccountWithVolumes), ctx, query)
}

// GetAccountsWithVolumes mocks base method.
func (m *MockLedger) GetAccountsWithVolumes(ctx context.Context, query ledgerstore.GetAccountsQuery) (*bunpaginate.Cursor[ledger.ExpandedAccount], error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetAccountsWithVolumes", ctx, query)
	ret0, _ := ret[0].(*bunpaginate.Cursor[ledger.ExpandedAccount])
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetAccountsWithVolumes indicates an expected call of GetAccountsWithVolumes.
func (mr *MockLedgerMockRecorder) GetAccountsWithVolumes(ctx, query any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAccountsWithVolumes", reflect.TypeOf((*MockLedger)(nil).GetAccountsWithVolumes), ctx, query)
}

// GetAggregatedBalances mocks base method.
func (m *MockLedger) GetAggregatedBalances(ctx context.Context, q ledgerstore.GetAggregatedBalanceQuery) (ledger.BalancesByAssets, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetAggregatedBalances", ctx, q)
	ret0, _ := ret[0].(ledger.BalancesByAssets)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetAggregatedBalances indicates an expected call of GetAggregatedBalances.
func (mr *MockLedgerMockRecorder) GetAggregatedBalances(ctx, q any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAggregatedBalances", reflect.TypeOf((*MockLedger)(nil).GetAggregatedBalances), ctx, q)
}

// GetLogs mocks base method.
func (m *MockLedger) GetLogs(ctx context.Context, query ledgerstore.GetLogsQuery) (*bunpaginate.Cursor[ledger.ChainedLog], error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetLogs", ctx, query)
	ret0, _ := ret[0].(*bunpaginate.Cursor[ledger.ChainedLog])
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetLogs indicates an expected call of GetLogs.
func (mr *MockLedgerMockRecorder) GetLogs(ctx, query any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetLogs", reflect.TypeOf((*MockLedger)(nil).GetLogs), ctx, query)
}

// GetMigrationsInfo mocks base method.
func (m *MockLedger) GetMigrationsInfo(ctx context.Context) ([]migrations.Info, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetMigrationsInfo", ctx)
	ret0, _ := ret[0].([]migrations.Info)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetMigrationsInfo indicates an expected call of GetMigrationsInfo.
func (mr *MockLedgerMockRecorder) GetMigrationsInfo(ctx any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetMigrationsInfo", reflect.TypeOf((*MockLedger)(nil).GetMigrationsInfo), ctx)
}

// GetTransactionWithVolumes mocks base method.
func (m *MockLedger) GetTransactionWithVolumes(ctx context.Context, query ledgerstore.GetTransactionQuery) (*ledger.ExpandedTransaction, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetTransactionWithVolumes", ctx, query)
	ret0, _ := ret[0].(*ledger.ExpandedTransaction)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetTransactionWithVolumes indicates an expected call of GetTransactionWithVolumes.
func (mr *MockLedgerMockRecorder) GetTransactionWithVolumes(ctx, query any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetTransactionWithVolumes", reflect.TypeOf((*MockLedger)(nil).GetTransactionWithVolumes), ctx, query)
}

// GetTransactions mocks base method.
func (m *MockLedger) GetTransactions(ctx context.Context, query ledgerstore.GetTransactionsQuery) (*bunpaginate.Cursor[ledger.ExpandedTransaction], error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetTransactions", ctx, query)
	ret0, _ := ret[0].(*bunpaginate.Cursor[ledger.ExpandedTransaction])
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetTransactions indicates an expected call of GetTransactions.
func (mr *MockLedgerMockRecorder) GetTransactions(ctx, query any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetTransactions", reflect.TypeOf((*MockLedger)(nil).GetTransactions), ctx, query)
}

// IsDatabaseUpToDate mocks base method.
func (m *MockLedger) IsDatabaseUpToDate(ctx context.Context) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsDatabaseUpToDate", ctx)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IsDatabaseUpToDate indicates an expected call of IsDatabaseUpToDate.
func (mr *MockLedgerMockRecorder) IsDatabaseUpToDate(ctx any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsDatabaseUpToDate", reflect.TypeOf((*MockLedger)(nil).IsDatabaseUpToDate), ctx)
}

// RevertTransaction mocks base method.
func (m *MockLedger) RevertTransaction(ctx context.Context, parameters command.Parameters, id *big.Int, force, atEffectiveDate bool) (*ledger.Transaction, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RevertTransaction", ctx, parameters, id, force, atEffectiveDate)
	ret0, _ := ret[0].(*ledger.Transaction)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// RevertTransaction indicates an expected call of RevertTransaction.
func (mr *MockLedgerMockRecorder) RevertTransaction(ctx, parameters, id, force, atEffectiveDate any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RevertTransaction", reflect.TypeOf((*MockLedger)(nil).RevertTransaction), ctx, parameters, id, force, atEffectiveDate)
}

// SaveMeta mocks base method.
func (m_2 *MockLedger) SaveMeta(ctx context.Context, parameters command.Parameters, targetType string, targetID any, m metadata.Metadata) error {
	m_2.ctrl.T.Helper()
	ret := m_2.ctrl.Call(m_2, "SaveMeta", ctx, parameters, targetType, targetID, m)
	ret0, _ := ret[0].(error)
	return ret0
}

// SaveMeta indicates an expected call of SaveMeta.
func (mr *MockLedgerMockRecorder) SaveMeta(ctx, parameters, targetType, targetID, m any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SaveMeta", reflect.TypeOf((*MockLedger)(nil).SaveMeta), ctx, parameters, targetType, targetID, m)
}

// Stats mocks base method.
func (m *MockLedger) Stats(ctx context.Context) (engine.Stats, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Stats", ctx)
	ret0, _ := ret[0].(engine.Stats)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Stats indicates an expected call of Stats.
func (mr *MockLedgerMockRecorder) Stats(ctx any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Stats", reflect.TypeOf((*MockLedger)(nil).Stats), ctx)
}

// MockBackend is a mock of Backend interface.
type MockBackend struct {
	ctrl     *gomock.Controller
	recorder *MockBackendMockRecorder
}

// MockBackendMockRecorder is the mock recorder for MockBackend.
type MockBackendMockRecorder struct {
	mock *MockBackend
}

// NewMockBackend creates a new mock instance.
func NewMockBackend(ctrl *gomock.Controller) *MockBackend {
	mock := &MockBackend{ctrl: ctrl}
	mock.recorder = &MockBackendMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockBackend) EXPECT() *MockBackendMockRecorder {
	return m.recorder
}

// CreateLedger mocks base method.
func (m *MockBackend) CreateLedger(ctx context.Context, name string, configuration driver.LedgerConfiguration) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateLedger", ctx, name, configuration)
	ret0, _ := ret[0].(error)
	return ret0
}

// CreateLedger indicates an expected call of CreateLedger.
func (mr *MockBackendMockRecorder) CreateLedger(ctx, name, configuration any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateLedger", reflect.TypeOf((*MockBackend)(nil).CreateLedger), ctx, name, configuration)
}

// DeleteLedgerMetadata mocks base method.
func (m *MockBackend) DeleteLedgerMetadata(ctx context.Context, param, key string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DeleteLedgerMetadata", ctx, param, key)
	ret0, _ := ret[0].(error)
	return ret0
}

// DeleteLedgerMetadata indicates an expected call of DeleteLedgerMetadata.
func (mr *MockBackendMockRecorder) DeleteLedgerMetadata(ctx, param, key any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteLedgerMetadata", reflect.TypeOf((*MockBackend)(nil).DeleteLedgerMetadata), ctx, param, key)
}

// GetLedger mocks base method.
func (m *MockBackend) GetLedger(ctx context.Context, name string) (*systemstore.Ledger, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetLedger", ctx, name)
	ret0, _ := ret[0].(*systemstore.Ledger)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetLedger indicates an expected call of GetLedger.
func (mr *MockBackendMockRecorder) GetLedger(ctx, name any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetLedger", reflect.TypeOf((*MockBackend)(nil).GetLedger), ctx, name)
}

// GetLedgerEngine mocks base method.
func (m *MockBackend) GetLedgerEngine(ctx context.Context, name string) (Ledger, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetLedgerEngine", ctx, name)
	ret0, _ := ret[0].(Ledger)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetLedgerEngine indicates an expected call of GetLedgerEngine.
func (mr *MockBackendMockRecorder) GetLedgerEngine(ctx, name any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetLedgerEngine", reflect.TypeOf((*MockBackend)(nil).GetLedgerEngine), ctx, name)
}

// GetVersion mocks base method.
func (m *MockBackend) GetVersion() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetVersion")
	ret0, _ := ret[0].(string)
	return ret0
}

// GetVersion indicates an expected call of GetVersion.
func (mr *MockBackendMockRecorder) GetVersion() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetVersion", reflect.TypeOf((*MockBackend)(nil).GetVersion))
}

// ListLedgers mocks base method.
func (m *MockBackend) ListLedgers(ctx context.Context, query systemstore.ListLedgersQuery) (*bunpaginate.Cursor[systemstore.Ledger], error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ListLedgers", ctx, query)
	ret0, _ := ret[0].(*bunpaginate.Cursor[systemstore.Ledger])
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListLedgers indicates an expected call of ListLedgers.
func (mr *MockBackendMockRecorder) ListLedgers(ctx, query any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListLedgers", reflect.TypeOf((*MockBackend)(nil).ListLedgers), ctx, query)
}

// UpdateLedgerMetadata mocks base method.
func (m_2 *MockBackend) UpdateLedgerMetadata(ctx context.Context, name string, m map[string]string) error {
	m_2.ctrl.T.Helper()
	ret := m_2.ctrl.Call(m_2, "UpdateLedgerMetadata", ctx, name, m)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpdateLedgerMetadata indicates an expected call of UpdateLedgerMetadata.
func (mr *MockBackendMockRecorder) UpdateLedgerMetadata(ctx, name, m any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateLedgerMetadata", reflect.TypeOf((*MockBackend)(nil).UpdateLedgerMetadata), ctx, name, m)
}
