// Code generated by MockGen. DO NOT EDIT.
//
// Generated by this command:
//
//	mockgen -write_source_comment=false -write_package_comment=false -source ../../controller/ledger/controller.go -destination mocks_ledger_controller_test.go -typed -package bulking --mock_names Controller=LedgerController . Controller
//

package bulking

import (
	context "context"
	sql "database/sql"
	reflect "reflect"

	bunpaginate "github.com/formancehq/go-libs/v3/bun/bunpaginate"
	migrations "github.com/formancehq/go-libs/v3/migrations"
	time "github.com/formancehq/go-libs/v3/time"
	ledger "github.com/formancehq/ledger/internal"
	ledger0 "github.com/formancehq/ledger/internal/controller/ledger"
	common "github.com/formancehq/ledger/internal/storage/common"
	ledger1 "github.com/formancehq/ledger/internal/storage/ledger"
	bun "github.com/uptrace/bun"
	gomock "go.uber.org/mock/gomock"
)

// LedgerController is a mock of Controller interface.
type LedgerController struct {
	ctrl     *gomock.Controller
	recorder *LedgerControllerMockRecorder
	isgomock struct{}
}

// LedgerControllerMockRecorder is the mock recorder for LedgerController.
type LedgerControllerMockRecorder struct {
	mock *LedgerController
}

// NewLedgerController creates a new mock instance.
func NewLedgerController(ctrl *gomock.Controller) *LedgerController {
	mock := &LedgerController{ctrl: ctrl}
	mock.recorder = &LedgerControllerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *LedgerController) EXPECT() *LedgerControllerMockRecorder {
	return m.recorder
}

// BeginTX mocks base method.
func (m *LedgerController) BeginTX(ctx context.Context, options *sql.TxOptions) (ledger0.Controller, *bun.Tx, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "BeginTX", ctx, options)
	ret0, _ := ret[0].(ledger0.Controller)
	ret1, _ := ret[1].(*bun.Tx)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// BeginTX indicates an expected call of BeginTX.
func (mr *LedgerControllerMockRecorder) BeginTX(ctx, options any) *LedgerControllerBeginTXCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BeginTX", reflect.TypeOf((*LedgerController)(nil).BeginTX), ctx, options)
	return &LedgerControllerBeginTXCall{Call: call}
}

// LedgerControllerBeginTXCall wrap *gomock.Call
type LedgerControllerBeginTXCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *LedgerControllerBeginTXCall) Return(arg0 ledger0.Controller, arg1 *bun.Tx, arg2 error) *LedgerControllerBeginTXCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *LedgerControllerBeginTXCall) Do(f func(context.Context, *sql.TxOptions) (ledger0.Controller, *bun.Tx, error)) *LedgerControllerBeginTXCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *LedgerControllerBeginTXCall) DoAndReturn(f func(context.Context, *sql.TxOptions) (ledger0.Controller, *bun.Tx, error)) *LedgerControllerBeginTXCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Commit mocks base method.
func (m *LedgerController) Commit(ctx context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Commit", ctx)
	ret0, _ := ret[0].(error)
	return ret0
}

// Commit indicates an expected call of Commit.
func (mr *LedgerControllerMockRecorder) Commit(ctx any) *LedgerControllerCommitCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Commit", reflect.TypeOf((*LedgerController)(nil).Commit), ctx)
	return &LedgerControllerCommitCall{Call: call}
}

// LedgerControllerCommitCall wrap *gomock.Call
type LedgerControllerCommitCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *LedgerControllerCommitCall) Return(arg0 error) *LedgerControllerCommitCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *LedgerControllerCommitCall) Do(f func(context.Context) error) *LedgerControllerCommitCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *LedgerControllerCommitCall) DoAndReturn(f func(context.Context) error) *LedgerControllerCommitCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// CountAccounts mocks base method.
func (m *LedgerController) CountAccounts(ctx context.Context, query common.ResourceQuery[any]) (int, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CountAccounts", ctx, query)
	ret0, _ := ret[0].(int)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CountAccounts indicates an expected call of CountAccounts.
func (mr *LedgerControllerMockRecorder) CountAccounts(ctx, query any) *LedgerControllerCountAccountsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CountAccounts", reflect.TypeOf((*LedgerController)(nil).CountAccounts), ctx, query)
	return &LedgerControllerCountAccountsCall{Call: call}
}

// LedgerControllerCountAccountsCall wrap *gomock.Call
type LedgerControllerCountAccountsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *LedgerControllerCountAccountsCall) Return(arg0 int, arg1 error) *LedgerControllerCountAccountsCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *LedgerControllerCountAccountsCall) Do(f func(context.Context, common.ResourceQuery[any]) (int, error)) *LedgerControllerCountAccountsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *LedgerControllerCountAccountsCall) DoAndReturn(f func(context.Context, common.ResourceQuery[any]) (int, error)) *LedgerControllerCountAccountsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// CountTransactions mocks base method.
func (m *LedgerController) CountTransactions(ctx context.Context, query common.ResourceQuery[any]) (int, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CountTransactions", ctx, query)
	ret0, _ := ret[0].(int)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CountTransactions indicates an expected call of CountTransactions.
func (mr *LedgerControllerMockRecorder) CountTransactions(ctx, query any) *LedgerControllerCountTransactionsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CountTransactions", reflect.TypeOf((*LedgerController)(nil).CountTransactions), ctx, query)
	return &LedgerControllerCountTransactionsCall{Call: call}
}

// LedgerControllerCountTransactionsCall wrap *gomock.Call
type LedgerControllerCountTransactionsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *LedgerControllerCountTransactionsCall) Return(arg0 int, arg1 error) *LedgerControllerCountTransactionsCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *LedgerControllerCountTransactionsCall) Do(f func(context.Context, common.ResourceQuery[any]) (int, error)) *LedgerControllerCountTransactionsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *LedgerControllerCountTransactionsCall) DoAndReturn(f func(context.Context, common.ResourceQuery[any]) (int, error)) *LedgerControllerCountTransactionsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// CreateTransaction mocks base method.
func (m *LedgerController) CreateTransaction(ctx context.Context, parameters ledger0.Parameters[ledger0.CreateTransaction]) (*ledger.Log, *ledger.CreatedTransaction, bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateTransaction", ctx, parameters)
	ret0, _ := ret[0].(*ledger.Log)
	ret1, _ := ret[1].(*ledger.CreatedTransaction)
	ret2, _ := ret[2].(bool)
	ret3, _ := ret[3].(error)
	return ret0, ret1, ret2, ret3
}

// CreateTransaction indicates an expected call of CreateTransaction.
func (mr *LedgerControllerMockRecorder) CreateTransaction(ctx, parameters any) *LedgerControllerCreateTransactionCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateTransaction", reflect.TypeOf((*LedgerController)(nil).CreateTransaction), ctx, parameters)
	return &LedgerControllerCreateTransactionCall{Call: call}
}

// LedgerControllerCreateTransactionCall wrap *gomock.Call
type LedgerControllerCreateTransactionCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *LedgerControllerCreateTransactionCall) Return(arg0 *ledger.Log, arg1 *ledger.CreatedTransaction, arg2 bool, arg3 error) *LedgerControllerCreateTransactionCall {
	c.Call = c.Call.Return(arg0, arg1, arg2, arg3)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *LedgerControllerCreateTransactionCall) Do(f func(context.Context, ledger0.Parameters[ledger0.CreateTransaction]) (*ledger.Log, *ledger.CreatedTransaction, bool, error)) *LedgerControllerCreateTransactionCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *LedgerControllerCreateTransactionCall) DoAndReturn(f func(context.Context, ledger0.Parameters[ledger0.CreateTransaction]) (*ledger.Log, *ledger.CreatedTransaction, bool, error)) *LedgerControllerCreateTransactionCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// DeleteAccountMetadata mocks base method.
func (m *LedgerController) DeleteAccountMetadata(ctx context.Context, parameters ledger0.Parameters[ledger0.DeleteAccountMetadata]) (*ledger.Log, bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DeleteAccountMetadata", ctx, parameters)
	ret0, _ := ret[0].(*ledger.Log)
	ret1, _ := ret[1].(bool)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// DeleteAccountMetadata indicates an expected call of DeleteAccountMetadata.
func (mr *LedgerControllerMockRecorder) DeleteAccountMetadata(ctx, parameters any) *LedgerControllerDeleteAccountMetadataCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteAccountMetadata", reflect.TypeOf((*LedgerController)(nil).DeleteAccountMetadata), ctx, parameters)
	return &LedgerControllerDeleteAccountMetadataCall{Call: call}
}

// LedgerControllerDeleteAccountMetadataCall wrap *gomock.Call
type LedgerControllerDeleteAccountMetadataCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *LedgerControllerDeleteAccountMetadataCall) Return(arg0 *ledger.Log, arg1 bool, arg2 error) *LedgerControllerDeleteAccountMetadataCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *LedgerControllerDeleteAccountMetadataCall) Do(f func(context.Context, ledger0.Parameters[ledger0.DeleteAccountMetadata]) (*ledger.Log, bool, error)) *LedgerControllerDeleteAccountMetadataCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *LedgerControllerDeleteAccountMetadataCall) DoAndReturn(f func(context.Context, ledger0.Parameters[ledger0.DeleteAccountMetadata]) (*ledger.Log, bool, error)) *LedgerControllerDeleteAccountMetadataCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// DeleteTransactionMetadata mocks base method.
func (m *LedgerController) DeleteTransactionMetadata(ctx context.Context, parameters ledger0.Parameters[ledger0.DeleteTransactionMetadata]) (*ledger.Log, bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DeleteTransactionMetadata", ctx, parameters)
	ret0, _ := ret[0].(*ledger.Log)
	ret1, _ := ret[1].(bool)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// DeleteTransactionMetadata indicates an expected call of DeleteTransactionMetadata.
func (mr *LedgerControllerMockRecorder) DeleteTransactionMetadata(ctx, parameters any) *LedgerControllerDeleteTransactionMetadataCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteTransactionMetadata", reflect.TypeOf((*LedgerController)(nil).DeleteTransactionMetadata), ctx, parameters)
	return &LedgerControllerDeleteTransactionMetadataCall{Call: call}
}

// LedgerControllerDeleteTransactionMetadataCall wrap *gomock.Call
type LedgerControllerDeleteTransactionMetadataCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *LedgerControllerDeleteTransactionMetadataCall) Return(arg0 *ledger.Log, arg1 bool, arg2 error) *LedgerControllerDeleteTransactionMetadataCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *LedgerControllerDeleteTransactionMetadataCall) Do(f func(context.Context, ledger0.Parameters[ledger0.DeleteTransactionMetadata]) (*ledger.Log, bool, error)) *LedgerControllerDeleteTransactionMetadataCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *LedgerControllerDeleteTransactionMetadataCall) DoAndReturn(f func(context.Context, ledger0.Parameters[ledger0.DeleteTransactionMetadata]) (*ledger.Log, bool, error)) *LedgerControllerDeleteTransactionMetadataCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Export mocks base method.
func (m *LedgerController) Export(ctx context.Context, w ledger0.ExportWriter) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Export", ctx, w)
	ret0, _ := ret[0].(error)
	return ret0
}

// Export indicates an expected call of Export.
func (mr *LedgerControllerMockRecorder) Export(ctx, w any) *LedgerControllerExportCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Export", reflect.TypeOf((*LedgerController)(nil).Export), ctx, w)
	return &LedgerControllerExportCall{Call: call}
}

// LedgerControllerExportCall wrap *gomock.Call
type LedgerControllerExportCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *LedgerControllerExportCall) Return(arg0 error) *LedgerControllerExportCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *LedgerControllerExportCall) Do(f func(context.Context, ledger0.ExportWriter) error) *LedgerControllerExportCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *LedgerControllerExportCall) DoAndReturn(f func(context.Context, ledger0.ExportWriter) error) *LedgerControllerExportCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetAccount mocks base method.
func (m *LedgerController) GetAccount(ctx context.Context, query common.ResourceQuery[any]) (*ledger.Account, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetAccount", ctx, query)
	ret0, _ := ret[0].(*ledger.Account)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetAccount indicates an expected call of GetAccount.
func (mr *LedgerControllerMockRecorder) GetAccount(ctx, query any) *LedgerControllerGetAccountCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAccount", reflect.TypeOf((*LedgerController)(nil).GetAccount), ctx, query)
	return &LedgerControllerGetAccountCall{Call: call}
}

// LedgerControllerGetAccountCall wrap *gomock.Call
type LedgerControllerGetAccountCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *LedgerControllerGetAccountCall) Return(arg0 *ledger.Account, arg1 error) *LedgerControllerGetAccountCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *LedgerControllerGetAccountCall) Do(f func(context.Context, common.ResourceQuery[any]) (*ledger.Account, error)) *LedgerControllerGetAccountCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *LedgerControllerGetAccountCall) DoAndReturn(f func(context.Context, common.ResourceQuery[any]) (*ledger.Account, error)) *LedgerControllerGetAccountCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetAggregatedBalances mocks base method.
func (m *LedgerController) GetAggregatedBalances(ctx context.Context, q common.ResourceQuery[ledger1.GetAggregatedVolumesOptions]) (ledger.BalancesByAssets, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetAggregatedBalances", ctx, q)
	ret0, _ := ret[0].(ledger.BalancesByAssets)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetAggregatedBalances indicates an expected call of GetAggregatedBalances.
func (mr *LedgerControllerMockRecorder) GetAggregatedBalances(ctx, q any) *LedgerControllerGetAggregatedBalancesCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAggregatedBalances", reflect.TypeOf((*LedgerController)(nil).GetAggregatedBalances), ctx, q)
	return &LedgerControllerGetAggregatedBalancesCall{Call: call}
}

// LedgerControllerGetAggregatedBalancesCall wrap *gomock.Call
type LedgerControllerGetAggregatedBalancesCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *LedgerControllerGetAggregatedBalancesCall) Return(arg0 ledger.BalancesByAssets, arg1 error) *LedgerControllerGetAggregatedBalancesCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *LedgerControllerGetAggregatedBalancesCall) Do(f func(context.Context, common.ResourceQuery[ledger1.GetAggregatedVolumesOptions]) (ledger.BalancesByAssets, error)) *LedgerControllerGetAggregatedBalancesCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *LedgerControllerGetAggregatedBalancesCall) DoAndReturn(f func(context.Context, common.ResourceQuery[ledger1.GetAggregatedVolumesOptions]) (ledger.BalancesByAssets, error)) *LedgerControllerGetAggregatedBalancesCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetMigrationsInfo mocks base method.
func (m *LedgerController) GetMigrationsInfo(ctx context.Context) ([]migrations.Info, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetMigrationsInfo", ctx)
	ret0, _ := ret[0].([]migrations.Info)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetMigrationsInfo indicates an expected call of GetMigrationsInfo.
func (mr *LedgerControllerMockRecorder) GetMigrationsInfo(ctx any) *LedgerControllerGetMigrationsInfoCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetMigrationsInfo", reflect.TypeOf((*LedgerController)(nil).GetMigrationsInfo), ctx)
	return &LedgerControllerGetMigrationsInfoCall{Call: call}
}

// LedgerControllerGetMigrationsInfoCall wrap *gomock.Call
type LedgerControllerGetMigrationsInfoCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *LedgerControllerGetMigrationsInfoCall) Return(arg0 []migrations.Info, arg1 error) *LedgerControllerGetMigrationsInfoCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *LedgerControllerGetMigrationsInfoCall) Do(f func(context.Context) ([]migrations.Info, error)) *LedgerControllerGetMigrationsInfoCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *LedgerControllerGetMigrationsInfoCall) DoAndReturn(f func(context.Context) ([]migrations.Info, error)) *LedgerControllerGetMigrationsInfoCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetSchema mocks base method.
func (m *LedgerController) GetSchema(ctx context.Context, version string) (*ledger.Schema, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetSchema", ctx, version)
	ret0, _ := ret[0].(*ledger.Schema)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetSchema indicates an expected call of GetSchema.
func (mr *LedgerControllerMockRecorder) GetSchema(ctx, version any) *LedgerControllerGetSchemaCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetSchema", reflect.TypeOf((*LedgerController)(nil).GetSchema), ctx, version)
	return &LedgerControllerGetSchemaCall{Call: call}
}

// LedgerControllerGetSchemaCall wrap *gomock.Call
type LedgerControllerGetSchemaCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *LedgerControllerGetSchemaCall) Return(arg0 *ledger.Schema, arg1 error) *LedgerControllerGetSchemaCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *LedgerControllerGetSchemaCall) Do(f func(context.Context, string) (*ledger.Schema, error)) *LedgerControllerGetSchemaCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *LedgerControllerGetSchemaCall) DoAndReturn(f func(context.Context, string) (*ledger.Schema, error)) *LedgerControllerGetSchemaCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetStats mocks base method.
func (m *LedgerController) GetStats(ctx context.Context) (ledger0.Stats, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetStats", ctx)
	ret0, _ := ret[0].(ledger0.Stats)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetStats indicates an expected call of GetStats.
func (mr *LedgerControllerMockRecorder) GetStats(ctx any) *LedgerControllerGetStatsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetStats", reflect.TypeOf((*LedgerController)(nil).GetStats), ctx)
	return &LedgerControllerGetStatsCall{Call: call}
}

// LedgerControllerGetStatsCall wrap *gomock.Call
type LedgerControllerGetStatsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *LedgerControllerGetStatsCall) Return(arg0 ledger0.Stats, arg1 error) *LedgerControllerGetStatsCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *LedgerControllerGetStatsCall) Do(f func(context.Context) (ledger0.Stats, error)) *LedgerControllerGetStatsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *LedgerControllerGetStatsCall) DoAndReturn(f func(context.Context) (ledger0.Stats, error)) *LedgerControllerGetStatsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetTransaction mocks base method.
func (m *LedgerController) GetTransaction(ctx context.Context, query common.ResourceQuery[any]) (*ledger.Transaction, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetTransaction", ctx, query)
	ret0, _ := ret[0].(*ledger.Transaction)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetTransaction indicates an expected call of GetTransaction.
func (mr *LedgerControllerMockRecorder) GetTransaction(ctx, query any) *LedgerControllerGetTransactionCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetTransaction", reflect.TypeOf((*LedgerController)(nil).GetTransaction), ctx, query)
	return &LedgerControllerGetTransactionCall{Call: call}
}

// LedgerControllerGetTransactionCall wrap *gomock.Call
type LedgerControllerGetTransactionCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *LedgerControllerGetTransactionCall) Return(arg0 *ledger.Transaction, arg1 error) *LedgerControllerGetTransactionCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *LedgerControllerGetTransactionCall) Do(f func(context.Context, common.ResourceQuery[any]) (*ledger.Transaction, error)) *LedgerControllerGetTransactionCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *LedgerControllerGetTransactionCall) DoAndReturn(f func(context.Context, common.ResourceQuery[any]) (*ledger.Transaction, error)) *LedgerControllerGetTransactionCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetTransactionsSum mocks base method.
func (m *LedgerController) GetTransactionsSum(ctx context.Context, account string) ([]ledger1.TransactionsSummary, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetTransactionsSum", ctx, account)
	ret0, _ := ret[0].([]ledger1.TransactionsSummary)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetTransactionsSum indicates an expected call of GetTransactionsSum.
func (mr *LedgerControllerMockRecorder) GetTransactionsSum(ctx, account any) *LedgerControllerGetTransactionsSumCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetTransactionsSum", reflect.TypeOf((*LedgerController)(nil).GetTransactionsSum), ctx, account)
	return &LedgerControllerGetTransactionsSumCall{Call: call}
}

// LedgerControllerGetTransactionsSumCall wrap *gomock.Call
type LedgerControllerGetTransactionsSumCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *LedgerControllerGetTransactionsSumCall) Return(arg0 []ledger1.TransactionsSummary, arg1 error) *LedgerControllerGetTransactionsSumCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *LedgerControllerGetTransactionsSumCall) Do(f func(context.Context, string) ([]ledger1.TransactionsSummary, error)) *LedgerControllerGetTransactionsSumCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *LedgerControllerGetTransactionsSumCall) DoAndReturn(f func(context.Context, string) ([]ledger1.TransactionsSummary, error)) *LedgerControllerGetTransactionsSumCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetTransactionsSumWithTimeRange mocks base method.
func (m *LedgerController) GetTransactionsSumWithTimeRange(ctx context.Context, account string, startTime, endTime *time.Time) ([]ledger1.TransactionsSummary, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetTransactionsSumWithTimeRange", ctx, account, startTime, endTime)
	ret0, _ := ret[0].([]ledger1.TransactionsSummary)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetTransactionsSumWithTimeRange indicates an expected call of GetTransactionsSumWithTimeRange.
func (mr *LedgerControllerMockRecorder) GetTransactionsSumWithTimeRange(ctx, account, startTime, endTime any) *LedgerControllerGetTransactionsSumWithTimeRangeCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetTransactionsSumWithTimeRange", reflect.TypeOf((*LedgerController)(nil).GetTransactionsSumWithTimeRange), ctx, account, startTime, endTime)
	return &LedgerControllerGetTransactionsSumWithTimeRangeCall{Call: call}
}

// LedgerControllerGetTransactionsSumWithTimeRangeCall wrap *gomock.Call
type LedgerControllerGetTransactionsSumWithTimeRangeCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *LedgerControllerGetTransactionsSumWithTimeRangeCall) Return(arg0 []ledger1.TransactionsSummary, arg1 error) *LedgerControllerGetTransactionsSumWithTimeRangeCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *LedgerControllerGetTransactionsSumWithTimeRangeCall) Do(f func(context.Context, string, *time.Time, *time.Time) ([]ledger1.TransactionsSummary, error)) *LedgerControllerGetTransactionsSumWithTimeRangeCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *LedgerControllerGetTransactionsSumWithTimeRangeCall) DoAndReturn(f func(context.Context, string, *time.Time, *time.Time) ([]ledger1.TransactionsSummary, error)) *LedgerControllerGetTransactionsSumWithTimeRangeCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetVolumesWithBalances mocks base method.
func (m *LedgerController) GetVolumesWithBalances(ctx context.Context, q common.PaginatedQuery[ledger1.GetVolumesOptions]) (*bunpaginate.Cursor[ledger.VolumesWithBalanceByAssetByAccount], error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetVolumesWithBalances", ctx, q)
	ret0, _ := ret[0].(*bunpaginate.Cursor[ledger.VolumesWithBalanceByAssetByAccount])
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetVolumesWithBalances indicates an expected call of GetVolumesWithBalances.
func (mr *LedgerControllerMockRecorder) GetVolumesWithBalances(ctx, q any) *LedgerControllerGetVolumesWithBalancesCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetVolumesWithBalances", reflect.TypeOf((*LedgerController)(nil).GetVolumesWithBalances), ctx, q)
	return &LedgerControllerGetVolumesWithBalancesCall{Call: call}
}

// LedgerControllerGetVolumesWithBalancesCall wrap *gomock.Call
type LedgerControllerGetVolumesWithBalancesCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *LedgerControllerGetVolumesWithBalancesCall) Return(arg0 *bunpaginate.Cursor[ledger.VolumesWithBalanceByAssetByAccount], arg1 error) *LedgerControllerGetVolumesWithBalancesCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *LedgerControllerGetVolumesWithBalancesCall) Do(f func(context.Context, common.PaginatedQuery[ledger1.GetVolumesOptions]) (*bunpaginate.Cursor[ledger.VolumesWithBalanceByAssetByAccount], error)) *LedgerControllerGetVolumesWithBalancesCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *LedgerControllerGetVolumesWithBalancesCall) DoAndReturn(f func(context.Context, common.PaginatedQuery[ledger1.GetVolumesOptions]) (*bunpaginate.Cursor[ledger.VolumesWithBalanceByAssetByAccount], error)) *LedgerControllerGetVolumesWithBalancesCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Import mocks base method.
func (m *LedgerController) Import(ctx context.Context, stream chan ledger.Log) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Import", ctx, stream)
	ret0, _ := ret[0].(error)
	return ret0
}

// Import indicates an expected call of Import.
func (mr *LedgerControllerMockRecorder) Import(ctx, stream any) *LedgerControllerImportCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Import", reflect.TypeOf((*LedgerController)(nil).Import), ctx, stream)
	return &LedgerControllerImportCall{Call: call}
}

// LedgerControllerImportCall wrap *gomock.Call
type LedgerControllerImportCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *LedgerControllerImportCall) Return(arg0 error) *LedgerControllerImportCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *LedgerControllerImportCall) Do(f func(context.Context, chan ledger.Log) error) *LedgerControllerImportCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *LedgerControllerImportCall) DoAndReturn(f func(context.Context, chan ledger.Log) error) *LedgerControllerImportCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Info mocks base method.
func (m *LedgerController) Info() ledger.Ledger {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Info")
	ret0, _ := ret[0].(ledger.Ledger)
	return ret0
}

// Info indicates an expected call of Info.
func (mr *LedgerControllerMockRecorder) Info() *LedgerControllerInfoCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Info", reflect.TypeOf((*LedgerController)(nil).Info))
	return &LedgerControllerInfoCall{Call: call}
}

// LedgerControllerInfoCall wrap *gomock.Call
type LedgerControllerInfoCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *LedgerControllerInfoCall) Return(arg0 ledger.Ledger) *LedgerControllerInfoCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *LedgerControllerInfoCall) Do(f func() ledger.Ledger) *LedgerControllerInfoCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *LedgerControllerInfoCall) DoAndReturn(f func() ledger.Ledger) *LedgerControllerInfoCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// InsertSchema mocks base method.
func (m *LedgerController) InsertSchema(ctx context.Context, parameters ledger0.Parameters[ledger0.InsertSchema]) (*ledger.Log, *ledger.InsertedSchema, bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "InsertSchema", ctx, parameters)
	ret0, _ := ret[0].(*ledger.Log)
	ret1, _ := ret[1].(*ledger.InsertedSchema)
	ret2, _ := ret[2].(bool)
	ret3, _ := ret[3].(error)
	return ret0, ret1, ret2, ret3
}

// InsertSchema indicates an expected call of InsertSchema.
func (mr *LedgerControllerMockRecorder) InsertSchema(ctx, parameters any) *LedgerControllerInsertSchemaCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InsertSchema", reflect.TypeOf((*LedgerController)(nil).InsertSchema), ctx, parameters)
	return &LedgerControllerInsertSchemaCall{Call: call}
}

// LedgerControllerInsertSchemaCall wrap *gomock.Call
type LedgerControllerInsertSchemaCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *LedgerControllerInsertSchemaCall) Return(arg0 *ledger.Log, arg1 *ledger.InsertedSchema, arg2 bool, arg3 error) *LedgerControllerInsertSchemaCall {
	c.Call = c.Call.Return(arg0, arg1, arg2, arg3)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *LedgerControllerInsertSchemaCall) Do(f func(context.Context, ledger0.Parameters[ledger0.InsertSchema]) (*ledger.Log, *ledger.InsertedSchema, bool, error)) *LedgerControllerInsertSchemaCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *LedgerControllerInsertSchemaCall) DoAndReturn(f func(context.Context, ledger0.Parameters[ledger0.InsertSchema]) (*ledger.Log, *ledger.InsertedSchema, bool, error)) *LedgerControllerInsertSchemaCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// IsDatabaseUpToDate mocks base method.
func (m *LedgerController) IsDatabaseUpToDate(ctx context.Context) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsDatabaseUpToDate", ctx)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IsDatabaseUpToDate indicates an expected call of IsDatabaseUpToDate.
func (mr *LedgerControllerMockRecorder) IsDatabaseUpToDate(ctx any) *LedgerControllerIsDatabaseUpToDateCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsDatabaseUpToDate", reflect.TypeOf((*LedgerController)(nil).IsDatabaseUpToDate), ctx)
	return &LedgerControllerIsDatabaseUpToDateCall{Call: call}
}

// LedgerControllerIsDatabaseUpToDateCall wrap *gomock.Call
type LedgerControllerIsDatabaseUpToDateCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *LedgerControllerIsDatabaseUpToDateCall) Return(arg0 bool, arg1 error) *LedgerControllerIsDatabaseUpToDateCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *LedgerControllerIsDatabaseUpToDateCall) Do(f func(context.Context) (bool, error)) *LedgerControllerIsDatabaseUpToDateCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *LedgerControllerIsDatabaseUpToDateCall) DoAndReturn(f func(context.Context) (bool, error)) *LedgerControllerIsDatabaseUpToDateCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ListAccounts mocks base method.
func (m *LedgerController) ListAccounts(ctx context.Context, query common.PaginatedQuery[any]) (*bunpaginate.Cursor[ledger.Account], error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ListAccounts", ctx, query)
	ret0, _ := ret[0].(*bunpaginate.Cursor[ledger.Account])
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListAccounts indicates an expected call of ListAccounts.
func (mr *LedgerControllerMockRecorder) ListAccounts(ctx, query any) *LedgerControllerListAccountsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListAccounts", reflect.TypeOf((*LedgerController)(nil).ListAccounts), ctx, query)
	return &LedgerControllerListAccountsCall{Call: call}
}

// LedgerControllerListAccountsCall wrap *gomock.Call
type LedgerControllerListAccountsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *LedgerControllerListAccountsCall) Return(arg0 *bunpaginate.Cursor[ledger.Account], arg1 error) *LedgerControllerListAccountsCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *LedgerControllerListAccountsCall) Do(f func(context.Context, common.PaginatedQuery[any]) (*bunpaginate.Cursor[ledger.Account], error)) *LedgerControllerListAccountsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *LedgerControllerListAccountsCall) DoAndReturn(f func(context.Context, common.PaginatedQuery[any]) (*bunpaginate.Cursor[ledger.Account], error)) *LedgerControllerListAccountsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ListLogs mocks base method.
func (m *LedgerController) ListLogs(ctx context.Context, query common.PaginatedQuery[any]) (*bunpaginate.Cursor[ledger.Log], error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ListLogs", ctx, query)
	ret0, _ := ret[0].(*bunpaginate.Cursor[ledger.Log])
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListLogs indicates an expected call of ListLogs.
func (mr *LedgerControllerMockRecorder) ListLogs(ctx, query any) *LedgerControllerListLogsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListLogs", reflect.TypeOf((*LedgerController)(nil).ListLogs), ctx, query)
	return &LedgerControllerListLogsCall{Call: call}
}

// LedgerControllerListLogsCall wrap *gomock.Call
type LedgerControllerListLogsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *LedgerControllerListLogsCall) Return(arg0 *bunpaginate.Cursor[ledger.Log], arg1 error) *LedgerControllerListLogsCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *LedgerControllerListLogsCall) Do(f func(context.Context, common.PaginatedQuery[any]) (*bunpaginate.Cursor[ledger.Log], error)) *LedgerControllerListLogsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *LedgerControllerListLogsCall) DoAndReturn(f func(context.Context, common.PaginatedQuery[any]) (*bunpaginate.Cursor[ledger.Log], error)) *LedgerControllerListLogsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ListSchemas mocks base method.
func (m *LedgerController) ListSchemas(ctx context.Context, query common.PaginatedQuery[any]) (*bunpaginate.Cursor[ledger.Schema], error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ListSchemas", ctx, query)
	ret0, _ := ret[0].(*bunpaginate.Cursor[ledger.Schema])
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListSchemas indicates an expected call of ListSchemas.
func (mr *LedgerControllerMockRecorder) ListSchemas(ctx, query any) *LedgerControllerListSchemasCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListSchemas", reflect.TypeOf((*LedgerController)(nil).ListSchemas), ctx, query)
	return &LedgerControllerListSchemasCall{Call: call}
}

// LedgerControllerListSchemasCall wrap *gomock.Call
type LedgerControllerListSchemasCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *LedgerControllerListSchemasCall) Return(arg0 *bunpaginate.Cursor[ledger.Schema], arg1 error) *LedgerControllerListSchemasCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *LedgerControllerListSchemasCall) Do(f func(context.Context, common.PaginatedQuery[any]) (*bunpaginate.Cursor[ledger.Schema], error)) *LedgerControllerListSchemasCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *LedgerControllerListSchemasCall) DoAndReturn(f func(context.Context, common.PaginatedQuery[any]) (*bunpaginate.Cursor[ledger.Schema], error)) *LedgerControllerListSchemasCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ListTransactions mocks base method.
func (m *LedgerController) ListTransactions(ctx context.Context, query common.PaginatedQuery[any]) (*bunpaginate.Cursor[ledger.Transaction], error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ListTransactions", ctx, query)
	ret0, _ := ret[0].(*bunpaginate.Cursor[ledger.Transaction])
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListTransactions indicates an expected call of ListTransactions.
func (mr *LedgerControllerMockRecorder) ListTransactions(ctx, query any) *LedgerControllerListTransactionsCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListTransactions", reflect.TypeOf((*LedgerController)(nil).ListTransactions), ctx, query)
	return &LedgerControllerListTransactionsCall{Call: call}
}

// LedgerControllerListTransactionsCall wrap *gomock.Call
type LedgerControllerListTransactionsCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *LedgerControllerListTransactionsCall) Return(arg0 *bunpaginate.Cursor[ledger.Transaction], arg1 error) *LedgerControllerListTransactionsCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *LedgerControllerListTransactionsCall) Do(f func(context.Context, common.PaginatedQuery[any]) (*bunpaginate.Cursor[ledger.Transaction], error)) *LedgerControllerListTransactionsCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *LedgerControllerListTransactionsCall) DoAndReturn(f func(context.Context, common.PaginatedQuery[any]) (*bunpaginate.Cursor[ledger.Transaction], error)) *LedgerControllerListTransactionsCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// LockLedger mocks base method.
func (m *LedgerController) LockLedger(ctx context.Context) (ledger0.Controller, bun.IDB, func() error, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "LockLedger", ctx)
	ret0, _ := ret[0].(ledger0.Controller)
	ret1, _ := ret[1].(bun.IDB)
	ret2, _ := ret[2].(func() error)
	ret3, _ := ret[3].(error)
	return ret0, ret1, ret2, ret3
}

// LockLedger indicates an expected call of LockLedger.
func (mr *LedgerControllerMockRecorder) LockLedger(ctx any) *LedgerControllerLockLedgerCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LockLedger", reflect.TypeOf((*LedgerController)(nil).LockLedger), ctx)
	return &LedgerControllerLockLedgerCall{Call: call}
}

// LedgerControllerLockLedgerCall wrap *gomock.Call
type LedgerControllerLockLedgerCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *LedgerControllerLockLedgerCall) Return(arg0 ledger0.Controller, arg1 bun.IDB, arg2 func() error, arg3 error) *LedgerControllerLockLedgerCall {
	c.Call = c.Call.Return(arg0, arg1, arg2, arg3)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *LedgerControllerLockLedgerCall) Do(f func(context.Context) (ledger0.Controller, bun.IDB, func() error, error)) *LedgerControllerLockLedgerCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *LedgerControllerLockLedgerCall) DoAndReturn(f func(context.Context) (ledger0.Controller, bun.IDB, func() error, error)) *LedgerControllerLockLedgerCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// RevertTransaction mocks base method.
func (m *LedgerController) RevertTransaction(ctx context.Context, parameters ledger0.Parameters[ledger0.RevertTransaction]) (*ledger.Log, *ledger.RevertedTransaction, bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RevertTransaction", ctx, parameters)
	ret0, _ := ret[0].(*ledger.Log)
	ret1, _ := ret[1].(*ledger.RevertedTransaction)
	ret2, _ := ret[2].(bool)
	ret3, _ := ret[3].(error)
	return ret0, ret1, ret2, ret3
}

// RevertTransaction indicates an expected call of RevertTransaction.
func (mr *LedgerControllerMockRecorder) RevertTransaction(ctx, parameters any) *LedgerControllerRevertTransactionCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RevertTransaction", reflect.TypeOf((*LedgerController)(nil).RevertTransaction), ctx, parameters)
	return &LedgerControllerRevertTransactionCall{Call: call}
}

// LedgerControllerRevertTransactionCall wrap *gomock.Call
type LedgerControllerRevertTransactionCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *LedgerControllerRevertTransactionCall) Return(arg0 *ledger.Log, arg1 *ledger.RevertedTransaction, arg2 bool, arg3 error) *LedgerControllerRevertTransactionCall {
	c.Call = c.Call.Return(arg0, arg1, arg2, arg3)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *LedgerControllerRevertTransactionCall) Do(f func(context.Context, ledger0.Parameters[ledger0.RevertTransaction]) (*ledger.Log, *ledger.RevertedTransaction, bool, error)) *LedgerControllerRevertTransactionCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *LedgerControllerRevertTransactionCall) DoAndReturn(f func(context.Context, ledger0.Parameters[ledger0.RevertTransaction]) (*ledger.Log, *ledger.RevertedTransaction, bool, error)) *LedgerControllerRevertTransactionCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Rollback mocks base method.
func (m *LedgerController) Rollback(ctx context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Rollback", ctx)
	ret0, _ := ret[0].(error)
	return ret0
}

// Rollback indicates an expected call of Rollback.
func (mr *LedgerControllerMockRecorder) Rollback(ctx any) *LedgerControllerRollbackCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Rollback", reflect.TypeOf((*LedgerController)(nil).Rollback), ctx)
	return &LedgerControllerRollbackCall{Call: call}
}

// LedgerControllerRollbackCall wrap *gomock.Call
type LedgerControllerRollbackCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *LedgerControllerRollbackCall) Return(arg0 error) *LedgerControllerRollbackCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *LedgerControllerRollbackCall) Do(f func(context.Context) error) *LedgerControllerRollbackCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *LedgerControllerRollbackCall) DoAndReturn(f func(context.Context) error) *LedgerControllerRollbackCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SaveAccountMetadata mocks base method.
func (m *LedgerController) SaveAccountMetadata(ctx context.Context, parameters ledger0.Parameters[ledger0.SaveAccountMetadata]) (*ledger.Log, bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SaveAccountMetadata", ctx, parameters)
	ret0, _ := ret[0].(*ledger.Log)
	ret1, _ := ret[1].(bool)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// SaveAccountMetadata indicates an expected call of SaveAccountMetadata.
func (mr *LedgerControllerMockRecorder) SaveAccountMetadata(ctx, parameters any) *LedgerControllerSaveAccountMetadataCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SaveAccountMetadata", reflect.TypeOf((*LedgerController)(nil).SaveAccountMetadata), ctx, parameters)
	return &LedgerControllerSaveAccountMetadataCall{Call: call}
}

// LedgerControllerSaveAccountMetadataCall wrap *gomock.Call
type LedgerControllerSaveAccountMetadataCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *LedgerControllerSaveAccountMetadataCall) Return(arg0 *ledger.Log, arg1 bool, arg2 error) *LedgerControllerSaveAccountMetadataCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *LedgerControllerSaveAccountMetadataCall) Do(f func(context.Context, ledger0.Parameters[ledger0.SaveAccountMetadata]) (*ledger.Log, bool, error)) *LedgerControllerSaveAccountMetadataCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *LedgerControllerSaveAccountMetadataCall) DoAndReturn(f func(context.Context, ledger0.Parameters[ledger0.SaveAccountMetadata]) (*ledger.Log, bool, error)) *LedgerControllerSaveAccountMetadataCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SaveTransactionMetadata mocks base method.
func (m *LedgerController) SaveTransactionMetadata(ctx context.Context, parameters ledger0.Parameters[ledger0.SaveTransactionMetadata]) (*ledger.Log, bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SaveTransactionMetadata", ctx, parameters)
	ret0, _ := ret[0].(*ledger.Log)
	ret1, _ := ret[1].(bool)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// SaveTransactionMetadata indicates an expected call of SaveTransactionMetadata.
func (mr *LedgerControllerMockRecorder) SaveTransactionMetadata(ctx, parameters any) *LedgerControllerSaveTransactionMetadataCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SaveTransactionMetadata", reflect.TypeOf((*LedgerController)(nil).SaveTransactionMetadata), ctx, parameters)
	return &LedgerControllerSaveTransactionMetadataCall{Call: call}
}

// LedgerControllerSaveTransactionMetadataCall wrap *gomock.Call
type LedgerControllerSaveTransactionMetadataCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *LedgerControllerSaveTransactionMetadataCall) Return(arg0 *ledger.Log, arg1 bool, arg2 error) *LedgerControllerSaveTransactionMetadataCall {
	c.Call = c.Call.Return(arg0, arg1, arg2)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *LedgerControllerSaveTransactionMetadataCall) Do(f func(context.Context, ledger0.Parameters[ledger0.SaveTransactionMetadata]) (*ledger.Log, bool, error)) *LedgerControllerSaveTransactionMetadataCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *LedgerControllerSaveTransactionMetadataCall) DoAndReturn(f func(context.Context, ledger0.Parameters[ledger0.SaveTransactionMetadata]) (*ledger.Log, bool, error)) *LedgerControllerSaveTransactionMetadataCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}
